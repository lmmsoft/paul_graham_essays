---
title: "黑客与画家"
original_title: "Hackers and Painters"
author: "Paul Graham"
translator: "deepseek-ai/DeepSeek-V3 (SiliconFlow)"
translate_date: "2025-07-14"
source_file: "Hackers and Painters.md"
---

# 黑客与画家

（以下为直接翻译结果，未添加任何说明或注释）

| | [](index.html)  

|  

2003年5月  

（本文改编自哈佛大学客座讲座，其中融合了早前在东北大学的演讲内容。）  

计算机科学研究生毕业后，我进入艺术学院学习绘画。许多人惊讶于一个热爱计算机的人竟会同时对绘画产生兴趣。他们似乎认为编程与绘画是截然不同的工作——编程是冰冷、精确且有条不紊的，而绘画则是原始冲动的狂热表达。  

这两种印象都是错误的。编程与绘画有许多共同点。事实上，在我认识的所有不同类型的人中，程序员与画家是最为相似的群体之一。  

程序员与画家的共同之处在于他们都是创造者。与作曲家、建筑师和作家一样，程序员与画家都在试图创造美好的事物。他们本质上并非在做研究，尽管在创造过程中发现新技术是锦上添花。  

我从不喜欢"计算机科学"这个术语。主要原因是它根本名不副实。计算机科学就像南斯拉夫一样，是历史偶然拼凑起来的松散学科集合。一端是本质为数学家却打着计算机科学旗号申请DARPA经费的人；中间是研究计算机"自然史"的学者——例如探索网络数据路由算法的行为；而另一端则是程序员，他们试图编写有趣的软件，对他们而言计算机只是表达媒介，就像混凝土之于建筑师或颜料之于画家。这就像把数学家、物理学家和建筑师硬塞进同一个系。  

有时程序员的工作被称为"软件工程"，但这个称呼同样具有误导性。优秀的软件设计师并不比建筑师更接近工程师。虽然建筑与工程的界限模糊，但确实存在：建筑师决定做什么，工程师解决怎么做。  

"做什么"与"怎么做"不应完全割裂。在不理解实现方法的情况下决策需求是危险的。但编程绝不仅限于按规格实现——最好的编程本身就是创造规格的过程，只不过最佳创造方式恰是通过实现来完成。  

或许有一天，"计算机科学"会像南斯拉夫一样解体。这未尝不是好事，尤其当我的精神故乡"编程"能因此获得独立。  

将这些不同性质的工作捆绑在同一个学科名下虽便于管理，却造成了认知混乱。这是我不喜欢"计算机科学"名称的另一原因。中间群体或许勉强算实验科学，但两端的程序员与数学家实际上都不从事科学研究。  

数学家对此似乎并不困扰。他们像数学系的同行一样愉快地证明定理，很快便忘记所在大楼外墙挂着"计算机科学"的牌子。但对程序员而言，这个标签成了问题。"科学"的称谓让他们误以为自己应该表现得像科学家。于是大学和研究实验室的程序员不再专注于设计优美软件这一真正追求，转而被迫撰写研究论文。  

理想情况下，论文只是形式——程序员先写出优秀软件，再附上一篇说明，论文成为软件成果的代理。但更多时候这种错位会引发问题：人们容易从构建美好事物滑向制造丑陋但更适合论文研究的产物。  

遗憾的是，美好事物往往不是最佳论文素材。首先，研究必须原创——任何写过博士论文的人都明白，确保探索处女地的最好方法就是圈一块无人问津的领域。其次，研究必须充实——而笨拙的系统能产出更"有料"的论文，因为你可以大书特书克服障碍的过程。没有什么比错误假设更能催生"充实问题"了，人工智能领域大多印证了这条规律：如果你假定知识能用谓词逻辑表达式表示，其参数代表抽象概念，你就有写不完的论文来解释如何实现这一点。正如里奇·里卡多常说："露西，你有太多解释要做。"  

创造美好事物的方法通常是对现有事物进行精妙调整，或以新颖方式组合既有想法。这类工作很难通过论文传达。  

既然如此，为何大学和研究机构仍以论文评价程序员？原因与用简单标准化测试衡量"学术能力"，或用代码行数评估程序员生产力如出一辙——这些测试易于实施，而半吊子简易测试的诱惑难以抗拒。  

衡量程序员真正的追求——设计优美软件——要困难得多。你需要良好的设计品味来评判设计优劣。而人们识别优秀设计的能力与其自信程度之间，即便存在关联也恐怕是负相关。  

唯一客观的检验标准是时间。经年累月，美好事物终将繁荣，丑陋终被淘汰。可惜这个时间跨度往往超越人类寿命。塞缪尔·约翰逊说作家声誉需要百年才能尘埃落定——你得等作家有影响力的朋友去世，再等他们的追随者全部离世。  

我认为程序员必须接受声誉中的巨大随机成分。在这方面他们与其他创造者并无二致。实际上他们还算幸运——编程领域的时尚影响力远不及绘画界。  

比被人误解更糟的是自我误解。我们习惯从相关领域寻找灵感。如果你身处计算机科学系，自然会倾向于相信编程是理论计算机科学的实践应用。整个研究生阶段，我心底总萦绕着不安，觉得自己应该掌握更多理论，并为考完三周就忘光所有内容而自责。  

如今我意识到这种想法是错误的。程序员需要理解计算理论的程度，就像画家需要了解颜料化学。你需要掌握时空复杂度计算和图灵完备性概念，或许还得记住状态机的概念（以备编写解析器或正则表达式库之需）。实际上画家需要记忆的颜料化学知识比这多得多。  

我发现最佳灵感来源并非名称带"计算机"的学科，而是其他创造者聚集的领域。绘画带来的灵感远比计算理论丰富。  

例如，大学时我被教导应该在纸上完全设计好程序才能接触计算机。但我发现自己的编程方式截然不同——我喜欢面对计算机而非纸张编程。更"糟糕"的是，我从不耐心写出完整正确的程序，而是先喷涌出满是缺陷的代码，再逐步修正。学校教的"调试是捕捉拼写错误与疏忽的最后环节"，而我的工作方式仿佛编程完全由调试构成。  

长久以来我为此感到愧疚，就像小学时为握笔姿势不规范而自卑。如果当时观察其他创造者——画家或建筑师，我本应意识到自己的行为有个名字：素描。现在看来，大学教的编程方法完全错误。你应该像作家、画家和建筑师那样，在编写过程中构思程序。  

这一认知对软件设计具有实际意义：编程语言首先应该是可塑的。它是构思程序的工具，而非表达既定思路的媒介。它应该是铅笔而非钢笔。如果人们真按大学教的方式编程，静态类型将是个好主意。但我认识的程序员无一如此工作。我们需要能涂鸦修改的语言，而非要求正襟危坐、像端着茶杯与严厉的编译器老阿姨礼貌交谈的语言。  

谈到静态类型，以创造者自居还能让我们避免困扰科学界的另一问题：数学嫉妒。科学工作者都暗自认为数学家更聪明（数学家自己也这么想）。结果就是人们竭力使自己的工作看起来更数学化。这对物理学或许无害，但离自然科学越远，问题就越严重。  

满页公式看起来如此权威（秘诀：用希腊字母变量更显高深）。于是人们强烈倾向于研究可形式化处理的问题，而非真正重要的问题。  

如果程序员认同作家和画家等同行的身份，就不会受此诱惑。作家和画家没有数学嫉妒，他们认为自己在做完全不同的事——我认为程序员也是。  

如果大学和研究机构阻碍程序员做真正想做的事，或许企业才是他们的归宿。可惜大多数企业同样限制程序员的自由。学术界强迫程序员成为科学家，企业则强迫他们成为工程师。  

我最近才意识到这点。雅虎收购Viaweb时询问我的意愿。由于不喜欢商业事务，我表示只想编程。但到了雅虎才发现，他们所谓的编程仅指实现软件而非设计软件。程序员被视为将产品经理"愿景"（如果这个词合适）转化为代码的技术员。  

这似乎是大型企业的默认模式。如此安排能降低结果的方差。真正具备软件设计能力的程序员凤毛麟角，企业管理者难以识别。因此多数公司不是将软件未来托付给杰出程序员，而是交由委员会设计，程序员仅负责实现。  

若你某天想赚钱，请记住：这正是创业公司能赢的原因。大公司降低设计结果的方差是为避免灾难，但抑制波动同时也抹去了高峰。这对大公司不是问题——它们不靠卓越产品取胜，只要比其它大公司少犯错就能赢。  

因此，若能找到方法与软件由产品经理设计的大公司展开设计对决，它们永远无法跟上你的步伐。不过这种机会不易寻找——就像很难与城堡内的敌人进行白刃战。例如开发比Microsoft Word更好的文字处理器很容易，但在操作系统垄断的城堡内，微软可能根本不会注意到你的存在。  

设计之战的战场应选在新兴市场——尚未建立防御工事的领域。在这里，大胆的设计方法加上让设计者亲自实现产品，能带来巨大成功。微软、苹果、惠普起步时都是如此。我猜几乎所有成功创业公司皆循此道。  

因此创建伟大软件的方法之一是自立门户。但创业有两大问题：首先，除了编程你不得不处理大量杂务。在Viaweb我能有1/4时间编程就算幸运，其余3/4时间所做之事从枯燥到恐怖不等。对此我有基准判断——某次不得不中途离开董事会去补牙，当躺在牙医椅上等待钻头时，我感觉像在度假。  

其次，能赚钱的软件与有趣的软件重合度很低。编程语言很有趣（微软首个产品正是编程语言），但现在没人愿为之付费。要想赚钱，你往往被迫解决那些棘手到没人愿免费处理的问题。  

所有创造者都面临这个困境。价格由供需决定，而解决个人用户日常问题的需求远大于有趣工作的需求。外百老汇演出的报酬不如在展会穿大猩猩装，写小说的收益不及为垃圾处理器写广告文案，开发编程语言的收入比不上将某公司的老旧数据库连接到Web服务器。  

对软件行业，我认为解决方案是几乎所有创造者都熟悉的概念：白天工作。这个词源自夜间演出的音乐家，广义指为谋生做一类工作，为热爱做另一类工作。  

几乎所有创造者职业生涯早期都有白天工作。画家与作家尤甚。若幸运，你能找到与真实工作密切相关的日间工作——音乐家常在唱片店工作，开发编程语言或操作系统的程序员或许能找到相关职位。  

当我说程序员应有白天工作、利用业余开发优美软件时，这并非新主张——开源运动的核心正在于此。我想强调的是开源可能是正确模式，因为其他领域创造者都不约而同验证了这点。  

令我惊讶的是竟有雇主反对程序员参与开源项目。在Viaweb，我们反而不愿雇佣没有个人项目的程序员。面试时最关注的是应聘者业余时间编写什么软件。除非热爱，否则无法真正精通某事——而热爱编程的人必然有自己的项目。  

由于程序员是创造者而非科学家，寻找隐喻的正确场所应是其他创造领域而非科学界。绘画还能教给我们什么？  

从绘画中我们能学习（或至少确认）的是编程的学习方法。绘画主要靠实践学习，编程亦然。多数程序员并非通过大学课程学会编程，而是十三岁时自己写程序起步。即便在大学课堂，编程也主要通过实践习得。  

画家会留下作品轨迹，你能看到他们"做中学"的过程。按时间顺序观察画作，会发现每幅画都建立在之前习得的基础上。当某幅画出现精彩处理时，通常能在早期作品中找到它的雏形。  

我认为多数创造者如此工作。作家与建筑师似乎也是。或许程序员应更像画家，定期从头开始而非经年累月修改同一项目、试图融入所有新想法。  

程序员通过实践学习的事实再次印证编程与科学的差异。科学家不是通过研究学习科学，而是通过实验和习题。科学家起步时做的是"完美"工作——重现他人成果。最终他们才能开展原创工作。而程序员从起点就是原创工作——只是最初质量极差。因此程序员始于原创而臻于精湛，科学家始于精湛而臻于原创。  

创造者另一学习途径是范例。对画家而言，博物馆是技法参考库。数百年来，临摹大师作品始终是传统绘画教育的一部分，因为临摹迫使你仔细观察绘画技法。  

作家也如此。本杰明·富兰克林通过总结艾迪生与斯蒂尔的散文要点并尝试复述来学习写作。雷蒙德·钱德勒对侦探小说也这样做。  

同样，程序员可通过研究优秀程序学习编程——不仅要看功能，还要读源码。开源运动未充分宣传的益处之一，就是让学习编程变得更简单。我学编程时主要依赖书中的例子，当时唯一的大型代码库是Unix，但它并非开源。多数人通过约翰·莱昂斯著作的盗版影印件阅读源码——这本书写于1977年，却直到1996年才获准出版。  

绘画给予我们的另一启示是作品的渐进完善过程。画作通常始于草图，细节逐步填充。但这不仅是填充过程——原始构思常被证明存在错误。X光显示无数画作中的肢体位置或面部特征都经过调整。  

这正是我们可以向绘画学习的地方。我认为编程也应如此。期待程序规格完美无缺是不现实的。承认这点并编写允许规格动态调整的代码才是上策。  

（大公司的结构使它们难以做到这点，这是创业公司的又一优势。）  

如今人人都知道过早优化的危害。我认为我们同样需要警惕过早设计——过早确定程序该做什么。  

合适的工具能帮助我们避免这一陷阱。优秀的编程语言应该像油画颜料般便于修改。动态类型在此有优势——你不必提前承诺具体数据表示。但我认为灵活性的关键在于语言必须高度抽象——最容易修改的程序就是最简短的程序。  

这听起来矛盾，但伟大画作必须超越必要完美。例如达芬奇在国家美术馆创作的《吉内薇拉·德·班琪》肖像，他在人物头部后方绘制了杜松灌木，并精心描绘每片叶子。许多画家可能认为背景只是衬托，没人会细看。  

但达芬奇不这么想。他对画作某部分的投入程度完全不取决于预期被关注度。他像迈克尔·乔丹一样永不懈怠。  

这种不懈终将获得回报，因为聚沙成塔，未被注意的细节终会显现整体效果。当人们走过《吉内薇拉·德·班琪》时，常常未看标签就已被吸引。所有未被单独关注的细节共同创造出震撼效果，如同千个微弱声音汇成和谐合唱。  

伟大软件同样需要对美的狂热追求。观察优秀软件内部，你会发现即使无人关注的部件也充满美感。我不敢自诩编写伟大软件，但就代码而言，我的执着程度若体现在日常生活，绝对够格被开处方药。看到缩进混乱或变量名丑陋的代码会让我抓狂。  

如果程序员只是将规格转化为代码的实施者，他本可以像挖沟工人一样从头到尾线性工作。但作为创造者，我们必须考虑灵感因素。  

编程如绘画，工作呈周期性。有时你会为新项目兴奋到每天工作16小时，有时则对一切提不起兴趣。  

要做好工作必须顺应这些周期，因为你的应对方式会影响周期效果。驾驶手动挡汽车上坡时，有时需要松开离合器以防熄火。同理，适度"松离合"能防止雄心熄火。绘画与编程都包含雄心勃勃的艰巨任务和令人安心的常规工作。明智的做法是保留些简单任务以备"熄火"时刻。  

对编程而言，这可以具体表现为积攒bug。我喜欢调试：这是编程难得如外人想象般直接的时刻。问题完全明确，你只需解决它。程序本应执行x却执行了y，问题出在哪？你终将获胜。这种体验如同粉刷墙壁般令人放松。  

绘画范例不仅能指导个人工作管理，还能启示协作方式。许多古代伟大艺术品都是多人合作成果，尽管博物馆墙上可能只标一个名字。达芬奇曾是韦罗基奥作坊的学徒，在其《基督受洗》中绘制了一位天使。这种情况是常态而非例外。米开朗基罗坚持独自完成西斯廷教堂天顶所有人物，反被视为特别敬业。  

据我所知，画家合作时从不共同绘制同一部分。通常大师负责主要人物，助手绘制其他部分和背景。但绝不会出现一人覆盖另一人工作的情况。  

我认为这也是软件协作的正确模式。切勿过度协作。当三四人共同修改同一段代码且无人真正负责时，代码会像公共休息室般荒凉破败、堆满垃圾。正确的协作方式是将项目划分为界限分明的模块，每个模块有明确负责人，模块间接口要像编程语言一样精心设计并尽可能清晰定义。  

如绘画般，多数软件服务于人类用户。因此程序员与画家一样，必须拥有同理心才能创造真正伟大的作品。你需要从用户角度思考问题。  

童年时大人总教导我换位思考。实践中这总意味着放弃自我意愿服从他人。这自然让同理心背上了恶名，我曾刻意避免培养它。  

天啊，我大错特错。事实证明，换位思考几乎是成功的秘诀。这未必意味着自我牺牲——远非如此。理解他人观点不代表要为其利益服务，在某些情境下（比如战争）你恰恰需要反其道而行。  

多数创造者为人类受众创作。要打动观众，必须理解他们的需求。几乎所有最伟大的绘画都是人物画，因为人类最感兴趣的就是人类自身。  

同理心可能是区分优秀程序员与伟大程序员的最重要标准。有些程序员聪明绝顶却缺乏同理心，近乎唯我论者。这类人很难设计出伟大软件，因为他们无法从用户角度思考。  

判断一个人同理心水平的方法，是观察他向非技术人员解释技术问题时的表现。我们可能都认识某些在其他方面聪明、却在这方面糟糕得可笑的人。如果在晚宴上被问及"什么是编程语言"，他们会回答："哦，高级语言是编译器用来生成目标代码的输入。"高级语言？编译器？目标代码？连编程语言都不懂的人显然更不懂这些术语。  

软件的部分使命是自我诠释。因此要写出好软件，必须理解用户认知的局限。用户会毫无准备地接触软件，它最好能符合他们的直觉预期——因为他们不会阅读手册。这方面我见过的最佳系统是1985年的初代Macintosh，它做到了软件几乎从未做到的事：开箱即用。  

源代码也应自我诠释。如果只能让人们记住一句编程箴言，我会选《计算机程序的构造与解释》开篇的那句：  

> 程序写给人读，只是顺带让机器执行。

你不仅需要对用户怀有同理心，对读者同样如此。这符合你的利益，因为你终将成为他们中的一员。许多黑客写完程序后，时隔六个月再回头看，发现自己完全无法理解代码如何运作。我认识好几个人因此发誓再也不碰Perl语言。[7]  

缺乏同理心常与高智商挂钩，某些地方甚至将其视为一种时尚。但我认为这两者毫无关联。在数学和自然科学领域取得成就确实不需要培养同理心，而这些领域的从业者往往聪慧过人，于是两种特质被错误地捆绑在一起。但现实中也不乏既愚钝又缺乏同理心之人——听听那些打进脱口秀热线的提问者就知道了，他们总是拐弯抹角地表达问题，主持人不得不反复帮他们重新组织语言。  

那么，如果黑客行为与绘画写作同理，它是否同样酷炫？毕竟人生只有一次，理应投身于伟大事业。  

遗憾的是，这个问题难有定论。声望的传播永远存在巨大时滞，就像遥远恒星发出的光芒。绘画如今的崇高地位源于五百年前大师们的创作，但当时根本没人觉得这些画作像今人认为的这般重要。若告诉乌尔比诺公爵费德里科·达·蒙特费尔特罗，将来人们记住他主要是因为皮耶罗·德拉·弗朗切斯卡画作里那个鼻子奇特的男人，当时的民众定会觉得荒谬绝伦。  

因此，尽管我承认眼下黑客文化似乎不及绘画酷炫，但我们必须记住：绘画在其鼎盛时期，也远不如今天这般受人尊崇。  

可以确定的是，此刻正是黑客文化的黄金时代。多数领域的巅峰之作都诞生于早期：1430至1500年间的油画至今无人超越；莎士比亚恰逢职业戏剧兴起之时，其成就令后世剧作家永远活在他的阴影下；阿尔布雷希特·丢勒之于版画，简·奥斯汀之于小说，莫不如此。  

历史总在重复相同的模式：新媒体出现时，人们热情高涨，短短几代人便穷尽其大部分可能性。黑客技术正处在这个爆发阶段。  

列奥纳多时代的绘画远不如他的杰作后来塑造的那般酷炫。黑客文化最终能达到的高度，取决于我们如何运用这个新兴媒介。  

**注释**  
[1] 摄影对绘画最致命的打击，或许是摧毁了画家最理想的谋生手段——历史上多数伟大画家依靠肖像画维持生计。  
[2] 据悉微软禁止员工参与开源项目（即便业余时间）。但如今顶尖黑客多投身开源，该政策恐怕只会让微软与一流程序员绝缘。  
[3] 大学所授编程知识如同教人评判书籍、衣着或约会对象：不过让你意识到高中时的糟糕品味。  
[4] 同理心应用案例：在Viaweb，当我们难以决策时，会思考"竞争对手最痛恨哪种方案？"某次竞品添加了华而不实的功能，因是其少数优势便大肆宣传。我们本可论证其无用性，但最终选择用行动激怒对手——当天下午就山寨出该功能。  
[5] 文本编辑器和编译器除外。黑客设计这些工具无需同理心，因为他们自己就是典型用户。  
[6] 严格说存在瑕疵——程序略微超出可用内存导致频繁磁盘交换，但只需加装硬盘即可解决。  
[7] 提升代码可读性不在于堆砌注释。我愿进一步引申阿贝尔森和萨斯曼的观点：编程语言本质是算法表达工具，其次才是计算机指令。优秀编程语言解释软件的效率应优于英语，注释只该出现在需要警示读者的"代码急弯"处，如同道路只在险弯处设置箭头标识。  

**致谢** 特雷弗·布莱克韦尔、罗伯特·莫里斯、丹·吉芬、丽莎·兰德尔审阅草稿，亨利·莱特纳与拉里·芬克尔斯坦邀请演讲。  

---  
| | [日文译本](http://www.shiro.dreamhost.com/scheme/trans/hp-j.html)  
| | | | [西班牙文译本](http://kapcoweb.com/p/hackers-y-pintores)  
| | [德文译本](http://www.langatigma.org/trans/hm.html)  
| | | | [葡萄牙文译本](http://www.sounerd.com.br/index.php?option=com_content&task=view&id=203&Itemid=43)  
| | [捷克文译本](http://blog.zvestov.cz/item/135)  
| | | | [《优秀设计源于糟糕设计》](http://www.uiweb.com/issues/issue08.htm)  
| | [高德纳：作为艺术的计算机编程](knuth.html)

你可以在[《黑客与画家》](http://www.amazon.com/gp/product/0596006624)一书中找到这篇文章以及其他14篇文章。