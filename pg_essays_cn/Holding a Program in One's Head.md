---
title: "将程序存于脑中"
original_title: "Holding a Program in One's Head"
author: "Paul Graham"
translator: "deepseek-ai/DeepSeek-V3 (SiliconFlow)"
translate_date: "2025-07-14"
source_file: "Holding a Program in One's Head.md"
---

# 将程序存于脑中

| | [](index.html)  

|  

2007年8月  

一位专注于自己代码的优秀程序员，能够像数学家把握正在钻研的难题那样，将整个程序装载在脑海中。数学家解题从不似学童般依赖纸笔演算。他们更多在脑中推演：通过深入理解问题空间，得以如漫步于童年故居的记忆般自如穿梭。编程的至高境界亦复如是。你将完整程序存于脑中，便能随心所欲地调遣它。  

这种能力在项目初期尤为珍贵，因为最初阶段最重要的是保持调整方向的灵活性。不仅是换种方式解决问题，更要能随时修正问题本身。  

你的代码即是你对探索中问题的认知。唯有当代码烙印在脑海中时，你才真正理解这个问题。  

将程序装入大脑并非易事。若中断项目数月，重拾时可能需要数日才能重新透彻理解。即便每日持续开发，每次开工仍需半小时"加载"程序到脑中。这尚且是最理想状况。在典型办公室环境中工作的普通程序员，从未进入过这种状态。或更直白地说——他们从未真正理解自己正在解决的问题。  

即使最优秀的程序员，也并非时刻将整个程序装载于脑中。但有些方法能帮助你接近这种状态：  

1. **规避干扰**。干扰对多数工作都有害，对编程尤甚，因为程序员通常游走在所能处理的信息复杂度极限边缘。  

干扰的危害性不取决于时长，而在于其对思维秩序的破坏程度。程序员离座购买三明治时，脑中代码不会消失。但错误的打断方式，三十秒就足以清空你的思维缓存。  

吊诡的是，计划内的干扰可能比突发干扰更致命。若知晓一小时后要开会，你根本不会着手处理复杂任务。

2. **长时间连续工作。** 由于每次开始编程时都有固定的启动成本，因此长时间集中工作比多次短时间工作更高效。当然，过度疲劳会导致效率下降——这个临界点因人而异。我听说过有人能连续编程36小时，但我个人最多只能坚持18小时，而最佳状态通常不超过12小时。  

身体承受极限并非最优解。分段工作既有代价也有益处：有时休息后重返问题，你会发现潜意识已为你准备好了答案。  

3. **使用简洁的语言。** 更强大的编程语言能让代码更短。程序员思考程序时往往受所用语言的影响。语言越简洁，程序就越短，也越容易在脑中加载和留存。  

采用自底向上的编程风格能放大高效语言的优势：通过分层编写程序，底层代码充当上层的编程语言。若处理得当，你只需在脑中维护最顶层的逻辑。  

4. **持续重写程序。** 重写常能催生更清晰的设计。即便没有这个效果，重写也迫使你完全理解程序——这是将代码装入大脑的最佳方式。  

5. **编写可重读的代码。** 所有程序员都知道代码可读性很重要。但你自己才是最重要的读者，尤其是在初期——原型阶段就是与自我的对话。为自己写代码时，优先级会有所不同：为他人编写时可能需要避免过度紧凑，像教科书般展开某些部分；而为脑内重载优化时，简洁才是王道。  

6. **小团队协作。** 当你在脑中构建程序时，思维边界往往止于自己负责的代码。对其他部分的理解会打折扣，更重要的是无法自由修改。因此团队规模越小，项目越能彻底演化。若只有一名程序员（初期常见），你甚至能进行全盘重构。

7. **避免多人修改同一段代码。** 你永远无法像理解自己的代码那样透彻地理解他人的代码。无论你多么仔细地阅读过，那也只是阅读而非创作。因此，如果一段代码由多人共同编写，没有一个人能像单一作者那样完全理解它。  

更何况，你无法安全地重构他人正在修改的代码。这不仅仅是需要获得许可的问题——你甚至不会允许自己产生这种念头。多人协作的代码重构如同修改法律；而独自掌控的代码重构则像是突然看懂了视觉错觉图的另一种解读方式。  

若要让多人协作项目，应将项目拆分为独立模块并分配给个人负责。  

8. **从小处着手。** 随着对程序的熟悉度增加，你会更容易在脑海中构建其完整图景。当你确信某些部分已被彻底探索后，就能将其视为黑箱处理。但项目初期时，你不得不直面所有细节。若一开始就处理过于庞大的问题，可能永远无法完全掌握全局。因此，当需要编写大型复杂程序时，最佳起点或许不是撰写详细规范，而是先构建能解决子问题的原型。无论计划有多少优势，往往都比不上将完整程序清晰映射在脑海中的价值。

程序员们常常会意外地同时满足这八点，这令人惊讶。某人有了一个新项目的想法，但由于未获官方批准，他只能在业余时间进行——结果反而效率更高，因为没有干扰。出于对新项目的热情，他连续工作数小时。由于最初只是个实验，他没有使用“生产级”语言，而是选择了“脚本”语言——实际上后者强大得多。他彻底重写程序多次；这在正式项目中不可行，但这是出于热爱的劳动，他追求完美。而且除了给自己看的笔记外，他不添加任何注释，因为只有他自己会看这段代码。他被迫在小团队中工作，要么是因为尚未向他人透露想法，要么是想法看起来太不靠谱而不允许其他人参与。即使有团队，也无法多人同时编辑同一代码，因为代码变化太快。项目最初规模很小，因为想法本身就很微小；他只是想尝试某个很酷的 hack。

更令人惊讶的是，许多官方批准的项目竟能完美避开这八点。事实上，观察大多数组织中软件的开发方式，几乎像是刻意反其道而行。某种意义上确实如此。自组织诞生以来，其核心特征之一就是将个体视为可互换的零件。这对可并行化的任务（如战争）很有效。历史上，训练有素的专业军队总能击败个人英雄主义的战士，无论后者多么勇猛。但构思想法很难并行化。而程序正是：想法。

组织不仅不喜欢依赖个人天才的想法，这甚至是一种同义反复。不依赖个人正是组织定义的一部分——至少是我们当前对组织的理解。

或许我们可以定义一种新型组织，既能整合个人努力，又不要求他们可互换。可以说市场就是这样一种组织形式，尽管更准确的说法可能是：市场是组织无法形成时的默认退化形态。

也许我们能做的最佳方案是某种折中，比如让组织中的编程部门以不同方式运作。对大公司而言，最优解可能甚至不是内部研发想法，而是直接[收购](hiring.html)它们。但无论解决方案是什么，第一步是意识到问题的存在。“软件公司”这个词本身就存在矛盾——两个词在相互拉扯。任何优秀程序员在大组织中都会与之冲突，因为组织设计的目标正是阻止程序员所追求的东西。

优秀程序员仍能设法完成很多工作。但这往往需要近乎反抗组织的行动。或许更多人能理解程序员的行为是由工作需求驱动的，这会有所帮助。他们并非不负责任才长时间沉迷工作、忽略其他义务，不写规格直接编程，或重写已能运行的代码；也并非不友善才偏好独自工作，或对敲门打招呼的人低吼。这些看似随机的恼人习惯有一个共同解释：将程序保持在脑海中的力量。

无论这种理解是否能帮助大组织，它肯定能帮助它们的竞争对手。大公司最薄弱的环节是不让程序员个体做出伟大成果。因此，如果你是初创公司，这正是攻击它们的突破口：选择那些需要在一个大脑中解决的问题。

**致谢** Sam Altman、David Greenspan、Aaron Iba、Jessica Livingston、Robert Morris、Peter Norvig、Lisa Randall、Emmett Shear、Sergei Tsarev 和 Stephen Wolfram 阅读了本文草稿。

---  
| | [日文译本](http://www.aoky.net/articles/paul_graham/head.htm)  
| | | | [简体中文译本](http://flyingapplet.spaces.live.com/blog/cns!F682AFBD82F7E261!547.entry)  
| | [葡萄牙文译本](http://www.sounerd.com.br/index.php?option=com_content&view=article&id=261:tellarin&catid=101:graham&Itemid=44)  
| | | | [保加利亚文译本](http://www.matematika.bg/wiki/%D0%9A%D0%B0%D0%BA_%D0%B4%D0%B0_%D0%B7%D0%B0%D0%B4%D1%8A%D1%80%D0%B6%D0%B8%D0%BC_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B0_%D0%B2_%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0%D1%82%D0%B0_%D1%81%D0%B8)  
| | [俄文译本](http://ryba4.com/translations/head)

***  
  
---