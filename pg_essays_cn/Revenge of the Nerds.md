---
title: "书呆子的逆袭"
original_title: "Revenge of the Nerds"
author: "Paul Graham"
translator: "deepseek-ai/DeepSeek-V3 (SiliconFlow)"
translate_date: "2025-07-14"
source_file: "Revenge of the Nerds.md"
---

# 书呆子的逆袭

| | [](index.html)  
  
|   
  
|  **想创业吗？** 获得[Y Combinator](http://ycombinator.com/apply.html)的资助。    
  
---  
  
2002年5月  
  
|  “我们原本瞄准C++程序员，结果成功把他们中的许多人拽到了离Lisp还剩一半路程的地方。”  
  
——Java规范合著者 Guy Steele   
---  
  
  
软件行业始终存在着两股势力的斗争：一派是脑袋尖尖的学院派，另一派是同样难缠的头发尖尖的老板派。大家都知道“头发尖尖的老板”是什么形象吧？我相信科技界大多数人不仅认得这个漫画角色，还能在自己公司里找到对应的真人原型。  

这位头发尖尖的老板神奇地结合了两种常见却鲜少共存的特质：(a) 他对技术一窍不通；(b) 却对技术决策有着异常坚定的主张。  

举个例子，假设你需要开发一款软件。这位老板既不懂软件运行原理，也分不清编程语言的区别，却能斩钉截铁地指定开发语言——必须是Java。  

为什么？让我们透视他的思维逻辑：Java是行业标准（因为媒体总在报道），选用它就不会惹麻烦；既然是标准，Java程序员必然遍地都是，当前团队若像往常一样神秘离职，替补人手随时能找到。  

这套说辞看似合理，实则建立在某个未被言明的错误假设上：老板认为所有编程语言都差不多。若真如此，他的选择确实明智——既然语言没差别，随大流最稳妥。  

但语言之间真的没有优劣之分吗？我们甚至无需讨论具体差异就能证伪这一点。若在1992年问同一位老板该用什么语言，他会毫不犹豫回答C++。如果语言真没区别，为何他的答案会随时间改变？更根本的问题是：若语言等同，Java开发者何必费心创造新语言？  

显然，新语言的诞生必然源于对旧语言的改进。Java之父高斯林在白皮书中明确表示，Java正是为解决C++的某些缺陷而设计。至此矛盾显现：语言并非等同。顺着老板的思维追溯到Java，再回溯Java的诞生动机，最终得出的结论恰恰推翻了他最初的假设。  

那么谁是对的？高斯林还是头发尖尖的老板？答案不言自明。特定场景下，某些语言确实更具优势。这引出了更深层的问题：Java针对哪些场景优化？何时该用Java而非C++？是否存在比二者更优的其他选择？  

一旦开始思考这些问题，就如同打开了潘多拉魔盒。若老板必须处理如此复杂的决策，他的大脑恐怕会当场宕机。只要坚信语言等同，他只需选择最流行的选项——这本就是时尚而非技术问题，他或许还能蒙对。但若承认语言差异，他就得同时求解两道难题：既要评估二十多种主流语言对当前需求的适配度（对此他一无所知），又要权衡每种语言的程序员储备和库资源（同样超出他的认知）。面对这扇门后的复杂世界，老板选择回避也就不足为奇了。  

坚信语言等同的代价是背离真相，但好处是让生活简单得多。我认为这正是该观点盛行的主因——它令人心安理得。  

我们觉得Java肯定很优秀，因为它是时髦的新语言。但果真如此吗？从宏观视角看，Java确实是编程语言界的新贵（尤其当你的视野被Sun公司的巨幅广告占据时）。但贴近观察会发现，极客圈对“酷”的评判存在梯度：在黑客亚文化中，Perl的酷炫指数远超Java（比如Slashdot就用Perl搭建，你绝对看不到这帮人用JSP）。而比Perl更年轻的Python，其用户又对Perl流露出优越感，还有[更多](accgen.html)新语言正在崛起。  

观察Java、Perl、Python的演进轨迹，会发现耐人寻味的规律——至少Lisp黑客能看出来。每种新语言都越来越像Lisp，Python甚至复刻了被许多Lisp黑客视为设计缺陷的特性。如今简单Lisp程序已能逐行翻译成Python。2002年的编程语言，终于快要追上1958年的水准。  

**追赶数学的脚步**  

我的意思是：约翰·麦卡锡在1958年发现的Lisp语言，其理念直到今天才被主流编程语言逐步赶上。  

这怎么可能？计算机技术不是日新月异吗？1958年的计算机还是冰箱大小的庞然大物，运算能力堪比电子表。如此古老的技术怎会仍具价值，甚至优于最新成果？  

答案在于：Lisp最初根本不是作为现代意义上的编程语言设计的。我们所说的编程语言是向计算机下达指令的工具。虽然麦卡锡最终确实想开发这种工具，但实际成型的Lisp却源于他的[理论探索](rootsoflisp.html)——为图灵机寻找更便捷的替代方案。正如他后来所言，

另一种证明Lisp比图灵机更简洁的方法是编写一个通用Lisp函数，并展示它比通用图灵机的描述更简短易懂。这个Lisp函数就是[_eval_](https://sep.turbifycdn.com/ty/cdn/paulgraham/jmc.lisp?t=1688221954&)...，它能计算Lisp表达式的值......编写_eval_需要发明一种将Lisp函数表示为Lisp数据的符号，这种符号在论文中被设计出来时，完全没想过它会在实践中用于表达Lisp程序。

接下来的事情发生在1958年末，麦卡锡的研究生史蒂夫·拉塞尔看到了这个_eval_的定义，意识到如果将其翻译成机器语言，结果将成为一个Lisp解释器。

这在当时是个巨大的惊喜。后来麦卡锡在采访中这样描述：

> 史蒂夫·拉塞尔说，看，我为什么不把这个_eval_程序化呢？我对他说，呵呵，你把理论和实践搞混了，这个_eval_是用来阅读的，不是用来计算的。但他还是去做了。也就是说，他将我论文中的_eval_编译成[IBM]704机器码，修复了一些错误，然后将其作为Lisp解释器发布——它确实就是。所以从那时起，Lisp基本上就有了今天的形式......

转眼间，大约就在几周之内，麦卡锡发现他的理论构想竟蜕变成了一门真正的编程语言——其强大程度甚至超出了他的预期。

因此，要解释这门诞生于1950年代的语言为何不过时，关键在于它本质并非技术而是数学，而数学永不褪色。Lisp真正应该对比的对象不是1950年代的硬件，而是诸如1960年问世至今仍是最快通用排序算法的快速排序。

1950年代幸存至今的另一门语言Fortran，则代表了语言设计的对立路径。Lisp本是意外成为编程语言的数学理论，Fortran则是刻意设计的编程语言——但以今日标准看是极其底层的语言。

1956年问世的[Fortran I](history.html)与当代Fortran截然不同。它本质上是带有数学运算的汇编语言，某些方面甚至不及现代汇编语言强大——例如没有子程序概念，只有跳转指令。如今的Fortran可以说更接近Lisp而非其始祖Fortran I。

Lisp与Fortran如同两棵进化树的树干，分别植根于数学理论与机器架构。此后这两棵树不断趋同：Lisp始于强大，随后二十年追求速度；所谓主流语言始于速度，此后四十年逐步增强表现力，如今最先进的已相当接近Lisp——接近，但仍缺几项关键要素……

**Lisp的独特基因**

初创之时，Lisp蕴含九大创新理念。其中部分已成常识，部分仅见于前沿语言，仍有两点至今为Lisp独有。按被主流采纳的顺序排列：

1. 条件语句。即if-then-else结构。如今视若平常，但Fortran I仅提供基于底层机器指令的条件跳转。

2. 函数类型。在Lisp中，函数与整数、字符串同属数据类型，具有字面量表示法，可存入变量，能作为参数传递。

3. 递归支持。Lisp是首个支持递归的编程语言。

4. 动态类型。Lisp中所有变量实质都是指针。类型属于值而非变量，变量赋值或绑定实为指针复制而非值拷贝。

5. 垃圾回收机制。

6. 由表达式构成的程序。Lisp程序是由表达式构成的树形结构，每个表达式都会返回一个值。这与Fortran及大多数后续语言形成鲜明对比——后者严格区分表达式与语句。

这种区分在Fortran I中很自然，因为当时语句不能嵌套。虽然数学运算需要表达式，但让其他结构返回值毫无意义，毕竟没有任何代码能接收这些值。

随着块结构语言的出现，这种限制消失了，但为时已晚。表达式与语句的区分已根深蒂固，从Fortran蔓延到Algol，继而影响了它们的所有后代语言。

7. 符号类型。符号本质上是指向哈希表中字符串的指针。因此可以通过比较指针来测试相等性，无需逐字符比对。

8. 使用符号与常量树形结构表示代码的标记法。

9. 全时态语言。读取时、编译时与运行时之间没有真正界限：你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。

读取时运行代码让用户能重定义Lisp语法；编译时运行代码是宏系统的根基；运行时编译代码使Lisp成为Emacs等程序的扩展语言；运行时读取代码则让程序能通过s表达式通信——这个理念后来以XML的形式被重新发明。

当Lisp首次问世时，这些理念与1950年代末期受硬件限制的主流编程实践相去甚远。随着时间的推移，以一系列流行语言为代表的默认语言正逐步向Lisp靠拢。理念1-5现已广泛普及，理念6开始进入主流视野，Python虽具备理念7的某种形式却缺乏对应语法。

而理念8可能是其中最耐人寻味的。理念8和9能成为Lisp的一部分纯属偶然，源于Steve Russell实现了McCarthy从未打算落地的构想。正是这些意外造就了Lisp奇特的外表与最鲜明的特质。Lisp的怪异并非源于特殊语法，而是因其本质上没有语法——你直接操作的是其他语言解析时生成的语法树，这些由Lisp原生链表构成的数据结构。

用语言自身的数据结构来表达程序被证明是革命性的特性。理念8与9的结合意味着你能编写生成程序的程序。这听起来或许离奇，却是Lisp的日常实践，最典型的实现方式就是宏。

"宏"在Lisp中的内涵远超其他语言。从简写到新语言的编译器，Lisp宏无所不包。若要真正理解Lisp或拓展编程视野，深入宏机制至关重要。

据我所知，真正的宏系统仍是Lisp的独门绝技。部分原因在于实现宏需要承受Lisp式的语法异质，更因为一旦突破这层能力极限，你所创造的将不再是新语言，而是Lisp的新方言。

虽是玩笑却属事实：若某语言包含car、cdr、cons、quote、cond、atom、eq等基本操作，以及基于链表的函数表示法，你就能重建整个Lisp体系——这正是McCarthy设计Lisp时的核心追求。

**语言的用武之地**

假设Lisp确为渐进逼近的极限，是否意味着应该用它开发软件？选择弱语言会损失多少？保持技术领先是否永远明智？流行度本身能否成为理由？比如技术外行主管坚持选用易招聘的语言是否正确？

当然存在编程语言无关紧要的项目。通常应用越复杂，强语言的杠杆效应越显著。但多数项目并不苛刻，日常编程多为胶水代码，此时选用熟悉且库支持良好的语言即可。例如Windows应用间数据传输，Visual Basic足矣。

虽能用Lisp编写胶水程序（我常用作桌面计算器），但其真正优势在于解决竞争激烈的复杂问题。典型案例是ITA软件为Orbitz开发的机票搜索系统——在Travelocity和Expedia垄断的市场中，他们用技术碾压了对手。

ITA的核心是20万行Common Lisp代码，其搜索能力超越仍在使用大型机时代技术的竞争对手数个量级。虽然ITA本质上也在使用"大型机时代语言"，但其工程师透露大量使用宏的事实毫不令人意外。

**向心力作用**

非常规技术确有代价，技术外行主管的担忧不无道理。但因认知局限，他们往往夸大风险。

使用小众语言可能引发三个问题：与其他语言交互障碍、可用库较少、招聘困难。这些问题的严重性取决于场景。若控制整个系统（如ITA掌握全部源码），语言选择完全自主，兼容性问题可自行修复。

服务器端应用更能接纳先进技术，这正是Jonathan Erickson所称"编程语言复兴"的主因。Perl和Python的兴起正源于服务器端应用。随着软件从桌面转向服务器（微软也不得不接受的趋势），中庸技术的压力将日益减弱。

库的重要性因项目而异：简单问题中现成库的价值可能超越语言本身。但对企业级软件产品（需多名程序员耗时半年以上开发），强语言的优势终将显现。

关于招聘难题实属过虑：优秀软件团队从不超过十人，任何知名语言都能满足此规模需求。若连十个Lisp程序员都招不到，恐怕公司选址本身就有问题。实际上，强语言可能缩减团队规模——既因需求减少，也因使用先进语言的程序员通常更优秀。

在Viaweb（现Yahoo Store）时期，我们使用Lisp、廉价Intel服务器、FreeBSD系统、无视SET标准等决策曾令投资人和收购方侧目。但最终证明，正是这些非常规选择创造了被收购的价值。

创业者当为用户而非投资人设计产品。赢得用户则万事俱备，失去用户则技术正统毫无意义。

**平庸的代价**

弱语言的效率损失有据可循。代码规模是最直观的衡量标准——高级语言提供更大抽象单元，如同用更少砖块砌同等围墙。强语言程序更短（非指字符数，而是独立元素量）。

强语言缩短代码的秘诀在于自底向上编程：在基础语言之上构建领域专用语言，再以其编写应用。这种组合代码远比纯基础语言实现更精简——正如压缩算法原理。其可维护性也更优，因为语言层通常无需改动。

代码规模至关重要，因为开发时间主要取决于长度。若某语言使代码膨胀三倍，耗时必然三倍——且无法通过增员解决，因为超限后新人只会拖累进度。Fred Brooks在《人月神话》中阐述的现象已被广泛证实。

Lisp相较C语言的代码压缩比普遍达7-10倍。而《新架构师》杂志引述ITA总裁称"一行Lisp可抵二十行C"。鉴于ITA系统混合使用Lisp/C++，此数据可信度较高。

我认为该倍数并非恒定——问题越复杂，程序员越优秀，差距越大。顶尖黑客能更充分释放工具潜能。

以ITA为例：若你用C语言竞争，其开发速度将领先20倍。你耗时一年的功能，他们三周即可复现；他们三个月的新成果，你需要五年追赶——这还是最理想状况。实际上，当底层语言超出人脑负荷极限时，项目很可能永远无法完成。

虽属极端案例（ITA团队异常优秀，C语言相对底层），但竞争市场中即便2-3倍效率差也足以决定生死。

**成功配方**

技术外行主管拒绝思考这种可能性。只要失败无法归咎，他们甘愿公司落败。个人最安全的策略就是随大流。

大企业称之为"行业最佳实践"——实为推卸责任的护身符。选择"最佳实践"意味着失败时无需担责：是行业的选择，而非个人决策。

该术语原用于会计领域，核心是"避免特立独行"。这在财务领域或许合理（"前沿"与"会计"本就违和），但套用于技术决策就会酿成错误。技术本应追求前沿，正如Erann Gat所言："行业最佳实践"带来的只是平庸。当决策导致开发效率被激进对手碾压时，"最佳"已成谬称。

因此我们获得两个珍贵认知：1. 语言能力存在差异；2. 多数管理者刻意忽视。二者结合便是致富配方。ITA的成功印证了这点：在软件行业制胜，只需挑战最难问题，选用最强语言，静待竞争对手的平庸管理者自缚手脚。

* * *
书呆子的复仇（第6部分，共9部分）

**附录：语言的威力**  

为了说明不同编程语言的相对威力，请思考以下问题：我们需要编写一个生成累加器的函数——该函数接收一个数字`n`，返回一个能接收另一个数字`i`并返回`n`累加`i`结果的函数。  

（注意是*累加*而非简单相加。累加器必须保持状态。）  

在Common Lisp中实现如下：  
```lisp
(defun foo (n) (lambda (i) (incf n i)))
```  
而在Perl 5中：  
```perl
sub foo { my ($n) = @_; sub {$n += shift} }
```  
Perl版本比Lisp多了参数手动提取的步骤。  

Smalltalk代码略长于Lisp：  
```smalltalk
foo: n 
    |s| 
    s := n. 
    ^[:i| s := s+i. ]
```  
因为虽然支持词法变量，但不能直接对参数赋值，必须创建新变量`s`。  

Javascript同样稍显冗长，因其区分语句和表达式，需显式`return`返回值：  
```javascript
function foo(n) { return function (i) { return n += i } }
```  
（公平而言，Perl也区分二者，但以典型Perl风格允许省略`return`。）  

若将上述代码转换为Python，则会遇到限制。由于Python不完全支持词法变量，必须创建数据结构存储`n`；且虽支持函数类型，但无字面量表示（除非函数体为单一表达式），故需命名函数返回。最终代码如下：  
```python
def foo(n):
    s = [n]
    def bar(i):
        s[0] += i
        return s[0]
    return bar
```  
Python用户或会质疑为何不能直接写作：  
```python
def foo(n): return lambda i: return n += i
```  
甚至：  
```python
def foo(n): lambda i: n += i
```  
我推测未来或许能实现。（但若不愿等待Python进化至Lisp的水平，他们完全可以...）  

在面向对象语言中，可通过定义含单方法的类来有限模拟闭包（引用外围作用域变量的函数），用字段替代外围变量。这迫使程序员手动完成本应由词法作用域编译器完成的代码分析，且无法处理多函数共享同一变量的情况，但简单场景尚可应付。  

Python专家普遍认为这是更"符合语言风格"的解决方案：  
```python
def foo(n):
    class acc:
        def __init__(self, s):
            self.s = s
        def inc(self, i):
            self.s += i
            return self.s
    return acc(n).inc
```  
或：  
```python
class foo:
    def __init__(self, n):
        self.n = n
    def __call__(self, i):
        self.n += i
        return self.n
```  
我列出这些是为避免Python拥护者指责曲解语言，但二者都比首个版本复杂。本质都是创建独立存储空间——只是用对象字段替代了列表头部。而`__call__`等特殊字段名的使用更像某种妥协。  

在Perl与Python的竞争中，Python阵营常标榜其语言比Perl更优雅。但本例表明：威力才是终极优雅——尽管语法稍显粗糙，Perl程序更简洁（元素更少）。  

其他语言表现如何？本次讨论涉及的Fortran、C、C++、Java和Visual Basic甚至难以解决该问题。Ken Anderson指出这是Java最接近的实现：  
```java
public interface Inttoint { public int call(int i); }
public static Inttoint foo(final int n) {
    return new Inttoint() {
        int s = n;
        public int call(int i) {
            s = s + i;
            return s;
        }
    };
}
```  
该方案仅支持整数，未达标准。经与Java开发者多次邮件讨论后，我认为要编写行为等同前例的多态版本，其难度介于极其棘手与不可能之间。若有实现者，我愿一观，但本人已放弃尝试。  

严格来说，并非无法用其他语言实现。图灵等价性意味着理论上任何语言都能编写任何程序。那么如何实现？极端情况下，可在弱语言中实现Lisp解释器。  

这听似玩笑，但大型项目中不同程度地频繁出现这种现象，甚至被命名为"格林斯潘第十定律"：

任何足够复杂的C或Fortran程序，都包含了一个临时拼凑、非正式规范、漏洞百出且运行缓慢的Common Lisp半成品实现。

当你试图解决一个难题时，问题不在于你是否会使用足够强大的语言，而在于你会选择：(a) 使用一门强大的语言，(b) 为其编写一个事实上的解释器，还是 (c) 自己成为这门语言的人肉编译器。我们在Python示例中已看到这种现象的萌芽——本质上我们正在模拟编译器为实现词法变量所生成的代码。

这种做法不仅普遍，甚至已成为行业惯例。例如在面向对象领域，人们频繁讨论"设计模式"。我不禁怀疑这些模式是否正是案例(c)——人肉编译器——的体现。当我在程序中看到模式时，我认为这是问题出现的征兆。程序的形态应当只反映其需要解决的问题。代码中任何其他规律性痕迹，至少在我看来，都意味着我正在使用的抽象不够强大——往往是在手工编写本应由宏展开生成的代码。


**注释**

* IBM 704中央处理器体积与家用冰箱相仿，但重量远超。CPU重3150磅，4K内存装在另一个重达4000磅的箱子里。而Sub-Zero 690作为最大型家用冰箱之一，重量仅656磅。
* 史蒂夫·拉塞尔还在1962年编写了首个(数字)电脑游戏《太空大战》。
* 若想哄骗呆板上司允许你用Lisp编程，不妨告诉他这是XML。
* 其他Lisp方言中的累加器生成器实现：Scheme版：(define (foo n) (lambda (i) (set! n (+ n i)) n))；Goo版：(df foo (n) (op incf n _)))；Arc版：(def foo (n) [++ n _])
* 埃兰·盖特关于JPL"行业最佳实践"的悲伤故事促使我探讨这个被普遍误用的表述。
* 彼得·诺维格发现《设计模式》中的23个模式有16个在Lisp中"[不可见或更简单](http://www.norvig.com/design-patterns/)"。
* 感谢肯·安德森、特雷弗·布莱克韦尔、埃兰·盖特、丹·吉芬、莎拉·哈林、杰里米·希尔顿、罗伯特·莫里斯、彼得·诺维格、盖伊·斯蒂尔和安东·范斯特拉滕等人解答各类语言问题及审阅本文草稿。文中观点责任均与上述人士无关。

**相关链接：**  

许多人对此文做出了回应，因此我另设了一个页面来讨论他们提出的问题：[《Re: 书呆子的复仇》](icadmore.html)。  

本文还在[LL1](http://www.ai.mit.edu/~gregs/ll1-discuss-archive-html/threads.html)邮件列表上引发了广泛且富有价值的讨论，尤其值得关注的是Anton van Straaten关于语义压缩的邮件。  

LL1上的部分讨论促使我在[《简洁即力量》](power.html)一文中更深入地探讨了语言能力的主题。  

更多关于[累加器生成器基准测试](accgen.html)的标准实现已单独整理成页。  

[日语译本](http://www.shiro.dreamhost.com/scheme/trans/icad-j.html)、[西班牙语译本](http://kapcoweb.com/p/docs/translations/revenge_of_the_nerds/revenge_of_the_nerds-es.html)、[中文译本](http://flyingapplet.spaces.live.com/blog/cns!F682AFBD82F7E261!375.entry)  

* * *

|  本文与其他14篇文章收录于[《黑客与画家》](http://www.amazon.com/gp/product/0596006624)一书中。