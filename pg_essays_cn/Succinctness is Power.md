---
title: "简洁即力量"
original_title: "Succinctness is Power"
author: "Paul Graham"
translator: "deepseek-ai/DeepSeek-V3 (SiliconFlow)"
translate_date: "2025-07-14"
source_file: "Succinctness is Power.md"
---

# 简洁即力量

| | [](index.html)  
  
|   
  
2002年5月  
  
|  |  "代数符号将大量意义压缩至狭小空间的能力，正是其能辅助我们进行复杂推理的另一优势。"  
  
——查尔斯·巴贝奇，引自艾弗森的图灵奖演讲  
  
---  
  
  
在LL1邮件列表关于《书呆子的复仇》引发议题的讨论中，保罗·普雷斯科特写下了令我印象深刻的话：

> Python的目标是规范性与可读性，而非简洁性。

表面看来，这对编程语言而言堪称致命评价。就我理解，简洁性=力量。若此等式成立，则替换可得：

> Python的目标是规范性与可读性，而非力量。

而这似乎并非一种你愿意接受的权衡（如果这确实算是一种权衡）。这几乎等同于说Python的目标并非成为一种高效的编程语言。

简洁是否等于强大？在我看来，这是个至关重要的问题，或许是语言设计领域最核心的命题，值得我们直面探讨。虽然我尚不确定答案是否简单肯定的，但这无疑是个值得深究的起点假设。

**核心假设**

我的假设是：简洁即力量，或者说二者近乎等同，除极端案例外可视作同义概念。

我认为编程语言存在的根本意义正在于追求简洁。计算机本可直接接受机器语言指令。我们之所以费心开发高级语言，核心动机在于获得杠杆效应——用10行高级语言代码表达（更重要的是思考）原本需要1000行机器语言才能实现的内容。换言之，高级语言的核心价值就在于压缩源代码规模。

如果精简代码是高级语言的使命，而事物的力量体现在其达成使命的程度，那么衡量编程语言力量的标准就是它能多大程度缩减程序体量。

反之，若某语言无法精简程序，就如同钝刀难裁物、印刷难辨识，从根本上背离了编程语言的应有之义。

**度量标准**

但"精简"具体指什么？最常用的代码规模指标是行数。然而这种度量方式盛行仅仅因其便于统计，无人真正认为它能准确反映程序长度。不同语言对单行代码量的约定各异：比如C语言中许多行仅含一两个分隔符。

另一个简易标准是字符总数，但这同样欠佳——某些语言（如Perl）只是使用更短的标识符。

我认为更合理的度量方式是"元素数量"，即用树状图表示源代码时的独立节点数。变量名、函数名、整型数、浮点数、文本段、模式元素、格式指令、新代码块等都算作独立元素。虽然存在边界情况（如-5算一个还是两个元素？），但多数情况跨语言通用，不影响比较结果。

该标准尚需完善，特定语言可能需要解释性调整，但其核心理念正确——衡量程序的组成部分数量。这种树状结构正是人脑理解程序时必须构建的心理模型，其规模与读写代码所需的心智劳动成正比。

**设计指导**

此类度量标准可用于跨语言比较，但对我而言其核心价值在于指导语言设计。最有意义的比较发生在同一语言的两种潜在变体之间：如何通过语言设计使程序更精简？

如果程序的概念负荷与其复杂度成正比，而程序员的概念承受力恒定，那么这个问题本质上等同于：如何让程序员实现最高效能？在我看来，这与"如何设计优秀语言"实为同一命题。

（顺带一提，语言设计过程最能彻底证伪"所有语言等价"的陈腐观点。设计新语言时，你持续在比较两种变体——采用某特性与否——以判断优劣。若这真是无意义的问题，不如直接抛硬币决策。）

追求简洁似乎是发现新思路的良方。若某项改动能普遍缩短各类程序，很可能意味着你发现了有价值的新抽象概念。甚至可编写程序辅助检测源代码中的重复模式。在众多语言中，以简洁著称者（如Forth、Joy、Icon）最可能提供创新灵感。

**比较研究**

据我所知，Fred Brooks在《人月神话》中最早探讨此议题。他指出无论使用何种语言，程序员日均产出代码量大致恒定。二十出头初读此论时，这个反直觉的发现令我震惊且深感其重大意义：这意味着(a)加速软件开发的唯一途径是采用更简洁的语言；(b)践行此道者将彻底甩开竞争对手。

若Brooks假说成立，它直指黑客精神的核心。此后多年间，我从正式研究到项目轶事，始终密切关注相关证据，从未发现反例。

虽然尚未见到确凿证据（也不期待见到），但类似Lutz Prechelt的编程语言比较研究虽得出预期结论，其测试案例往往过短而缺乏意义。更有效的测试应针对需月余开发周期的程序。若如我所信——语言的核心价值在于辅助思考（而非仅表达既定思路），那么终极检验标准是它能支持创作何种新事物。因此任何基于预设规范的比较测试都略有偏差。

语言的真正考验在于发现和解决新问题的能力，而非解决他人已定义问题的效率。这两者判然有别。艺术领域，刺绣与马赛克适合制作预定图案，但完全不适合即兴创作。当需要边创作边构思（如人物肖像等复杂作品时），必须采用铅笔、水墨或油画等流动性媒介。事实上，挂毯与马赛克的制作流程正是先绘制油画再临摹（"cartoon"一词原指此类底稿）。

这意味着我们永远难以准确比较编程语言的相对力量。虽可获得精确数据，却难言真实准确。特别是专门设计的语言对比研究，因受限于小规模课题和预设问题，往往会低估强大语言的实际效能。

来自实践领域的报告虽不如"科学"研究精确，却更具参考价值。例如爱立信的Ulf Wiger通过[研究](http://www.erlang.se/publications/Ulf_Wiger.pdf)得出结论：Erlang比C++简洁4-10倍，软件开发速度同比提升。

爱立信内部开发项目的比较显示，无论使用何种语言（Erlang、PLEX、C、C++或Java），软件开发各阶段的代码行/小时生产力都大致相当。因此，不同语言之间的差异主要体现在源代码体积上。

这项研究还明确探讨了布鲁克斯书中仅隐含提及的观点（因为他测量的是调试后的代码行数）：用更强大的语言编写的程序往往错误更少。对于像网络交换机这样的应用，这本身就成为了目的，可能比程序员的生产效率更重要。

**品味测试**

最终，我认为你必须跟随直觉。用这种语言编程感觉如何？我认为找到（或设计）最佳语言的方法是变得对语言如何让你思考极其敏感，然后选择/设计感觉最好的语言。如果某些语言特性笨拙或限制性强，别担心，你会察觉到的。

这种高度敏感会带来代价。你会发现无法忍受用笨拙的语言编程。我觉得没有宏的语言编程限制性令人难以忍受，就像习惯动态类型的人无法忍受必须回到需要声明每个变量类型、且不能创建不同类型对象列表的语言编程一样。

不只我这样。我认识许多Lisp黑客都有这种感受。事实上，衡量编程语言相对能力最准确的指标可能是：了解该语言的人中，愿意为使用该语言接受任何工作（无论应用领域）的比例。

**限制性**

我认为大多数黑客都明白语言感觉受限意味着什么。当你感到受限制时发生了什么？我想这就像你想走的路被堵住，不得不绕远路到达目的地。你有话想说，但语言不允许。

我认为真正的问题在于，限制性语言就是不够简洁的语言。问题不仅在于无法按计划表达，更在于语言迫使你绕的弯路更长。做个思想实验：假设你想写某个程序，语言不允许你按计划表达，但强迫你用更短的其他方式写出来。至少对我来说，这不会感觉很受限。就像想走的路被堵住，路口的警察却指引你走捷径而非绕路。太棒了！

我认为限制感大多（90%？）源于被迫用比脑中更冗长的语言写程序。限制性主要源于缺乏简洁性。所以当语言感觉受限时，大多意味着它不够简洁；而不简洁的语言自然会感觉受限。

**可读性**

开篇引文还提到另外两个特质：规律性和可读性。我不确定规律性是什么，也不清楚规律且可读的代码比单纯可读的代码有何优势（如果有的话）。但我想我明白可读性的含义，它也与简洁性相关。

这里我们必须谨慎区分单行代码的可读性和整个程序的可读性。后者才是关键。我承认一行Basic可能比一行Lisp更易读。但用Basic写的程序会比用Lisp写的相同程序行数更多（尤其是进入格林斯潘领域后）。阅读Basic程序的总工作量必然更大。

总努力 = 每行努力 × 行数

我并不像确信简洁性直接等同于威力那样，确信可读性与简洁性成正比，但简洁性无疑是影响可读性的一个因素（从数学意义上讲；参见上文等式）。因此，声称一门语言的目标是可读性而非简洁性，甚至可能没有意义；这就像说目标是可读性，而非可读性一样。

对于初次接触一门语言的用户来说，每行代码的可读性意味着源代码看起来不会令人望而生畏。因此，强调每行可读性可能是一个好的营销决策，即使它是一个糟糕的设计决策。这与让人们分期付款的成功策略如出一辙：不是用高昂的预付价格吓退他们，而是告诉他们低廉的月付金额。然而，分期付款对买家来说总体上是不利的，就像每行可读性对程序员可能也是如此。买家将不得不支付大量看似低廉的款项；而程序员将不得不阅读大量看似可读的代码行。

这种权衡在编程语言出现之前就已存在。如果你习惯了阅读小说和报纸文章，第一次阅读数学论文可能会令人沮丧。可能需要半小时才能读完一页。然而，我相当确定问题并不在于符号，尽管感觉上可能是这样。数学论文难以阅读是因为其中的思想本身就很难。如果你用散文来表达同样的思想（就像数学家们在发展出简洁符号之前不得不做的那样），它们并不会变得更容易阅读，因为论文会膨胀到一本书的篇幅。

**到什么程度？**

许多人拒绝接受简洁性等于威力的观点。我认为更有用的做法不是简单地争论它们是否相同，而是问：简洁性在多大程度上等于威力？因为显然，简洁性是高级语言的主要目标之一。如果不是全部目标，那么它们还有什么其他目标，这些其他功能相对而言有多重要？

我提出这个问题不仅仅是为了让辩论更加文明。我真的很想知道答案。在什么情况下，一门语言会因为过于简洁而适得其反？

我最初的假设是，除了病态的例子，我认为简洁性可以被视为与威力相同。我的意思是，在任何人们设计的语言中，它们会是相同的，但如果有人想设计一门语言明确反驳这一假设，他们或许能做到。实际上，我甚至对此也不确定。

**语言，而非程序**

我们应该明确，我们讨论的是语言的简洁性，而不是单个程序的简洁性。单个程序当然可能写得过于紧凑。

我在《On Lisp》中写过这一点。一个复杂的宏可能需要节省其自身长度的许多倍才能被认为是合理的。如果编写一个复杂的宏每次使用可以节省十行代码，而宏本身有十行代码，那么使用超过一次就能在代码行数上实现净节省。但这仍然可能是一个糟糕的决定，因为宏定义比普通代码更难阅读。你可能需要使用宏十次或二十次，才能实现可读性的净改善。

我相信每种语言都有这样的权衡（尽管我怀疑随着语言变得更强大，这种权衡的代价会更高）。每个程序员一定都见过一些聪明的家伙通过使用可疑的编程技巧使代码略微缩短的例子。

所以这一点没有争议——至少对我来说没有。单个程序当然可能因为过于简洁而适得其反。问题是，一门语言是否可能如此？一门语言是否会迫使程序员以牺牲整体可读性为代价，写出（在元素上）简短的代码？

很难想象一门语言会过于简洁的一个原因是，如果存在某种过于紧凑的表达方式，可能也存在一种更长的表达方式。例如，如果你觉得使用大量宏或高阶函数的Lisp程序过于紧凑，你可以选择写出与Pascal同构的代码。如果你不想在Arc中将阶乘表示为高阶函数的调用（`(rec zero 1 * 1-)`），你也可以写出一个递归定义：`(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))`。尽管我一时想不出任何例子，但我对一门语言是否可能过于简洁的问题很感兴趣。是否存在迫使你以晦涩难懂的方式编写代码的语言？如果有人有例子，我会非常感兴趣。

（提醒：我所寻找的是根据上文概述的“元素”指标非常紧凑的程序，而不仅仅是由于可以省略分隔符和所有东西都有一个字符名称而显得短的程序。）

---

| | [日语翻译](http://www.shiro.dreamhost.com/scheme/trans/power-j.html)  
  
| | [俄语翻译](http://www.melikyan.com/dalshe/articles/power.html)  
  
| | [Lutz Prechelt: 七种语言的比较](http://wwwipd.ira.uka.de/~prechelt/Biblio/jccpprtTR.pdf)  
  
| | [Erann Gat: Lisp vs. Java](http://www.flownet.com/gat/papers/lisp-java.pdf)  
  
| | [Peter Norvig 尝试 Prechelt 的测试](http://www.norvig.com/java-lisp.html)  
  
| | [Matthias Felleisen: 语言的表达能力](http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz)  
  
| | [Kragen Sitaker: 冗余与威力](redund.html)  
  
| | [Forth](http://www.colorforth.com/)  
  
| | [Joy](http://www.latrobe.edu.au/philosophy/phimvt/joy.html)  
  
| | [Icon](http://www.cs.arizona.edu/icon/)  
  
| | [J](http://www.jsoftware.com/books/help/primer/contents.htm)  
  
| | [K](http://www.cosy.com/language/k-lang.htm)

***  
  
---