---
title: "受欢迎

（注：由于提供的原文仅包含标题“Being Popular”，翻译结果即为“受欢迎”。若需翻译完整文章，请提供更多内容。）"
original_title: "Being Popular"
author: "Paul Graham"
translator: "deepseek-ai/DeepSeek-V3 (SiliconFlow)"
translate_date: "2025-07-14"
source_file: "Being Popular.md"
---

# 受欢迎

（注：由于提供的原文仅包含标题“Being Popular”，翻译结果即为“受欢迎”。若需翻译完整文章，请提供更多内容。）

| | [](index.html)  

|  

2001年5月  

（本文是为一种[新语言](arc.html)撰写的商业计划类文章，因此忽略了优秀编程语言最重要的特征——极其强大的抽象能力——这一点的缺失被视为理所当然。）  

我的一位朋友曾告诉一位著名的操作系统专家，他想设计一种真正优秀的编程语言。那位专家回应说这是浪费时间，因为编程语言的流行与否与它们的优点无关，所以无论他的语言多优秀，都不会有人使用。至少，这正是他设计的语言的遭遇。  

什么让一门语言流行？流行语言是否配得上它们的流行度？定义一门优秀编程语言是否值得？又该如何定义？  

我认为答案可以从黑客身上找到，了解他们想要什么。编程语言是为黑客服务的，一门语言的好坏（作为编程语言而非指称语义或编译器设计的练习）取决于黑客是否喜欢它。  

**1 流行机制**  

确实，大多数人不会仅凭语言优点选择编程语言。多数程序员使用的语言由他人指定。但外部因素对语言流行度的影响可能被高估了。更大的问题在于，黑客对优秀语言的理解与多数语言设计者不同。  

两者之间，黑客的意见才是关键。编程语言不是数学定理，而是为人设计的工具，必须适应人类的优缺点，就像鞋子必须适应人脚。如果穿上鞋就挤脚，无论它作为雕塑多么优雅，都是双坏鞋。  

或许大多数程序员无法分辨语言优劣，但这与其他工具无异。这并不意味着设计优秀语言是徒劳的。[顶尖黑客](design.html)能识别优秀语言并会使用它。诚然，顶尖黑客是极少数，但他们编写了所有优秀软件，其影响力使得其他程序员会跟随他们使用的语言。实际上，这种影响常以指令形式出现：顶尖黑客常作为上司或导师决定他人使用的语言。  

黑客的意见并非决定语言流行度的唯一力量——遗留系统（如Cobol）和营销炒作（如Ada、Java）也起作用——但我认为长期来看这是最强大的力量。给定初始关键规模和足够时间，一门语言的流行度终将与其价值匹配。而流行度会进一步区分语言优劣，因为真实用户的反馈总会推动改进。看看任何流行语言在其生命周期中的变化：Perl和Fortran是极端案例，但就连Lisp也变化巨大。例如Lisp 1.5没有宏，这一特性是在MIT黑客用Lisp编写真实程序数年后才演化出来的。[1]  

因此，无论语言是否需要优秀才能流行，我认为语言必须流行才能变得优秀，且必须持续流行以保持优秀。编程语言的技术前沿不会停滞。然而今天的Lisp仍基本停留在1980年代MIT的水平，因为那是Lisp最后一次拥有足够庞大且高要求的用户群。  

当然，黑客需要先知道一门语言才会使用它。他们如何知晓？通过其他黑客。但首先必须有一群初始用户，其他人才能听说这门语言。这个初始群体需要多大？多少用户能形成关键规模？凭直觉，我认为二十人足矣。如果有二十名独立用户（即自主选择使用该语言的人），这门语言就是真实的。  

达到这个目标并不容易。从零到二十可能比从二十到一千更难。获取初始二十名用户的最佳方式或许是特洛伊木马策略：提供人们想要的应用，而这个应用恰好用新语言编写。  

**2 外部因素**  

首先承认一个确实影响语言流行的外部因素：要流行，一门语言必须成为流行系统的脚本语言。Fortran和Cobol是早期IBM主机的脚本语言，C是Unix的脚本语言，后来Perl也是。Tcl是Tk的脚本语言，Java和Javascript旨在成为浏览器的脚本语言。  

Lisp未能大规模流行，因为它不是任何大规模流行系统的脚本语言。它残存的流行度可追溯至1960-70年代，当时它是MIT的脚本语言。那个时代许多顶尖程序员都与MIT有关联。在1970年代初C语言出现前，MIT的Lisp方言MacLisp是严肃黑客愿意使用的少数语言之一。  

如今Lisp是两个中等流行系统（Emacs和Autocad）的脚本语言，因此我猜测现今大多数Lisp编程是用Emacs Lisp或AutoLisp完成的。  

编程语言从不孤立存在。"Hack"是及物动词——黑客总在hack某物——实践中语言优劣取决于它所hack的对象。因此要设计流行语言，要么提供超越语言本身的系统，要么让语言替代现有系统的脚本语言。  

Common Lisp不受欢迎的部分原因是它成了孤儿。它最初伴随Lisp Machine系统诞生，但1980年代通用处理器性能提升碾压了Lisp Machine（与并行计算机）。如果Common Lisp能成为优秀的Unix脚本语言，或许能保持流行。可惜它在这方面糟糕透顶。  

这种状况可描述为"语言不被基于自身优点评判"，也可理解为"除非同时是某系统的脚本语言，否则编程语言不算真正的编程语言"。只有感到意外时才会觉得这不公平。我认为这与要求语言必须拥有实现一样公平——这是编程语言本质的一部分。  

当然，编程语言需要优秀实现，且必须免费。公司会为软件付费，但个体黑客不会，而你需要吸引的正是黑客。  

语言还需要相关书籍。这本书应该薄而精，充满优秀示例，K&R（《C程序设计语言》）是理想范本。目前几乎可以说语言需要一本O'Reilly出版的书——这正成为黑客认可的标准。  

在线文档也不可少。事实上，书籍可以从在线文档起步。但纸质书尚未过时：其格式便利，出版商的事实审查虽不完美却是有效过滤器。书店仍是了解新语言的重要场所。  

**3 简洁性**  

假设你能提供语言必需的三个要素（免费实现、书籍和可hack的对象），如何设计黑客喜欢的语言？  

黑客热爱简洁。他们像数学家与现代主义建筑师般懒惰：痛恨一切冗余。可以说黑客选择语言时（至少潜意识里）会考量需键入的总字符数。即便这不完全准确，语言设计者也应以此为准则。  

试图用冗长的类英语表达式照顾用户是错误做法。Cobol因此臭名昭著。让黑客写：  

将x加至y得到z  

而非  

z = x+y  

无异于侮辱其智商兼亵渎神明。  

有人认为Lisp应用first和rest替代car和cdr以提升可读性。这对初学者或许适用，但黑客很快就能掌握car代表列表首元素、cdr代表剩余部分。使用first和rest意味着增加50%的输入量。而且这两个词长度不同，导致连续调用时参数无法对齐（car和cdr常如此排列）。我发现代码的对齐方式极其重要：用变宽字体显示Lisp代码时我几乎无法阅读，其他语言用户也反映类似问题。  

强类型语言在简洁性上失分。在其他条件相同时，没人愿意以一堆声明开始程序。任何能隐式表达的内容都应隐式处理。  

单个标记也应简短。Perl与Common Lisp在此问题上分处两极：Perl程序可密集如密码，而Common Lisp内置操作符的名称长得可笑。Common Lisp设计者可能假设用户会用文本编辑器自动补全这些长名称。但长名称的代价不仅是输入耗时，还包括阅读负担和屏幕空间占用。  

**4 可hack性**  

对黑客而言，比简洁更重要的是：能够实现所想。编程语言史上，大量精力被用于阻止程序员进行"不当"操作。这是危险的傲慢——语言设计者怎能预知程序员的所有需求？设计者应假设用户是天才，需要完成设计者未曾预料的任务，而非需要保护的笨蛋。笨蛋总会搬石砸脚：你可以阻止他访问其他包的变量，但无法阻止他设计糟糕程序解决错误问题并耗费无限时间。  

优秀程序员常需进行危险或"不雅"操作。所谓"不雅"，指绕过语言试图呈现的语义 facade，例如获取高级抽象的内部表示。黑客热爱hacking，这意味着深入事物内部并质疑原始设计。  

允许自己被质疑。任何工具都会被以设计者未预料的方式使用，对编程语言这种高度复杂的工具更是如此。许多黑客会以你无法想象的方式调整你的语义模型。我的建议是：允许他们；在不危及垃圾回收器等运行时系统的前提下，尽可能向程序员开放内部机制。  

在Common Lisp中，我常需要遍历结构体字段（例如清理对已删除对象的引用或查找未初始化字段）。我知道结构体本质上是向量，却无法编写适用于任意结构体的通用函数，只能通过字段名访问——因为这是结构体的设计本意。  

黑客可能仅需在大型程序中偶尔突破既定模型，但这种能力的存在意义重大。这不仅是解决问题的方式，更带来某种快感：黑客分享着外科医生摆弄内脏的秘密愉悦，或青少年挤痘痘的隐秘乐趣。[2]至少对男性而言，某些恐怖事物具有致命吸引力。《Maxim》杂志每年出版的写真集混合着性感女郎与血腥事故的照片，他们深谙读者心理。  

历史上，Lisp在允许黑客为所欲为方面表现优异。Common Lisp的政治正确性是个异数。早期Lisp允许接触一切，所幸这种精神很大程度上通过宏保留下来。能对源代码进行任意转换是多么美妙！  

经典宏是真正的黑客工具——简单、强大而危险。其原理极易理解：对宏参数调用函数，返回值替换宏调用。卫生宏则体现相反哲学，试图保护你免于理解其运作机制。我从未见过能用一句话解释清楚的卫生宏。它们是"决定程序员该要什么"这一危险的典型例证。卫生宏旨在防止变量捕获等问题，但某些宏正需要变量捕获功能。  

真正优秀的语言应既干净又肮脏：设计干净，核心由少量高正交性的操作符组成；但又足够肮脏，允许黑客为所欲为。C语言如此，早期Lisp亦如此。真正的黑客语言总带些痞气。  

优秀编程语言应具备让"软件工程"人士摇头的特性。连续体的另一端是Ada和Pascal这类模范生语言，适合教学却别无他用。  

**5 一次性程序**  

要吸引黑客，语言必须适合编写他们想写的程序。出人意料的是，这意味着它必须擅长编写一次性程序。  

一次性程序是为特定临时任务快速编写的程序：自动化系统管理任务、生成模拟测试数据或转换数据格式等。令人惊讶的是，这些程序常像二战期间美国大学搭建的"临时"建筑一样永不消失。许多会演变成具有真实功能和用户的正式程序。  

我猜测优秀的大型程序都如此诞生，而非像胡佛水坝般从一开始就宏大设计。从零构建庞然大物令人畏惧。当项目过于庞大时，人们会不堪重负，导致项目停滞或产出僵化死板的作品：购物中心般的伪市中心、巴西利亚式的规划城市、Ada而非C般的语言。  

另一种构建大型程序的方式是从一次性程序开始持续改进。这种方式压力较小，且设计能通过演化受益。若做调查，这可能是多数大型程序的开发方式。那些如此演化的程序很可能仍用原始语言编写，因为除非政治原因，程序很少被移植。因此吊诡的是：要让语言用于大型系统，必须让它适合编写一次性程序——因为大型系统正源于此。  

Perl是这一理念的鲜明例证。它不仅为编写一次性程序设计，自身几乎就是个一次性程序。Perl最初是生成报表的工具集，随着用户编写的一次性程序规模扩大才演变成编程语言。直到Perl 5（甚至更晚）它才适合编写严肃程序，但早已广泛流行。  

什么使语言适合一次性程序？首先必须易于获取。一次性程序预期一小时写完，因此语言最好已预装在所用电脑上。不能是需先安装才能使用的语言。C因随操作系统分发而存在，Perl因最初是系统管理员工具而被预装。  

"易于获取"不止于安装。具有命令行交互界面的语言比需单独编译运行的语言更易获取。流行语言应是交互式且启动迅速的。  

一次性程序还需要简洁。黑客永远热爱简洁，对预期一小时完成的程序更是如此。  

**6 库**  

极致的简洁是直接调用现成程序。这引向我认为日益重要的语言特性：库函数。Perl因强大的字符串处理库而胜出。这类库对一次性程序尤为重要，因为它们常用于数据转换或提取。许多Perl程序最初可能只是几个库调用的组合。  

未来五十年编程语言的进步将很大程度上关乎库函数。未来的语言将拥有与核心语言同样精心设计的库。语言设计的焦点不再是强类型/弱类型、面向对象/函数式等争论，而是如何设计伟大库。那些沉迷于类型系统设计的设计者可能对此嗤之以鼻——这几乎像在写应用程序！但语言是为程序员服务的，而库正是程序员所需。  

设计优秀库极难。绝非简单堆砌代码。当库过于庞大时，寻找合适函数可能比自己编写更耗时。库需要像核心语言一样用少量正交操作符设计，程序员应能凭直觉猜测所需库调用。  

Common Lisp的短板正在于此。其字符串处理库极其基础，操作系统交互库几乎不存在。由于历史原因，Common Lisp试图假装操作系统不存在。无法与OS交互意味着仅用内置操作符难以编写严肃程序，必须借助实现相关的hack——而这些hack往往无法满足需求。如果Common Lisp拥有强大字符串库和良好OS支持，黑客对Lisp的评价会高得多。  

**7 语法**  

采用Lisp语法（或更准确地说，无语法）的语言可能流行吗？我尚无定论。但我认为语法并非Lisp当前不流行的主因。Common Lisp存在比陌生语法更严重的问题。我认识许多习惯前缀语法的程序员仍默认使用Perl，因其强大字符串库和OS交互能力。  

前缀表示法存在两个潜在问题：对程序员陌生，以及不够紧凑。Lisp界的传统智慧认为前者是主因。我不确定。确实，前缀表示法让普通程序员恐慌，但普通程序员的意见无关紧要——语言流行与否取决于顶尖黑客的评价，而我认为顶尖黑客能适应前缀表示法。Perl语法可能晦涩难懂，但这并未阻碍其流行，反而可能助长了Perl信徒的形成。  

更严重的问题是前缀表示法的冗余性。对顶尖黑客这确实是问题：没人愿意写(aref a x y)而非a[x,y]。  

针对此案例，我们有巧妙的解决方案：若将数据结构视为索引的函数，可写作(a x y)，比Perl形式更简短。类似技巧可缩短其他表达式。  

通过缩进语义化可消除（或可选）大量括号。程序员本就按缩进阅读代码：当缩进与定界符冲突时，人们遵循缩进。缩进语义化既能消除此类常见错误来源，又能缩短程序。  

有时中缀语法更易读，数学表达式尤其如此。我虽毕生使用Lisp，仍不习惯前缀数学表达式。但为代码生成方便，需要支持任意数量参数的操作符。因此若实现中缀语法，应通过读取宏实现。  

我们不应教条地反对为Lisp引入语法——只要它能明确转换为底层S表达式。Lisp已拥有不少语法，只要不强制使用，增加更多未必是坏事。Common Lisp中某些分隔符为语言保留，暗示至少部分设计者预期未来会增加语法。  

Common Lisp中最不合Lisp风格的语法出现在格式化字符串中：format本身就是一门语言，且非Lisp语言。若有增加Lisp语法的计划，格式化说明符应被纳入其中。若宏能像生成其他代码那样生成格式化说明符，将是巨大进步。  

一位著名Lisp黑客告诉我，他的《CLTL》总在format章节自然展开。我的也是。这或许暗示改进空间，也可能表明程序频繁进行I/O操作。  

**8 效率**  

众所周知，优秀语言应生成高效代码。但我认为高效代码主要不来自语言设计层面的决策。如Knuth早已指出的，速度仅在某些关键瓶颈处重要；而众多程序员发现，这些瓶颈的位置常被误判。  

因此实践中，获取高效代码的途径是拥有优秀性能分析器，而非通过强类型等语言特性。你不需要知道程序中每个调用的参数类型，但必须能在瓶颈处声明类型。更重要的是，必须能定位瓶颈所在。  

人们对Lisp的一个抱怨是难以判断操作的开销。这可能属实，也可能是高度抽象语言不可避免的代价。无论如何，优秀性能分析器将极大缓解此问题：你会很快了解哪些操作昂贵。  

部分问题源于社会因素。语言设计者喜欢编写快速编译器，这衡量着他们的技艺。他们将性能分析器视为附加品。但实际上，优秀性能分析器对提升程序速度的作用可能超过生成高效代码的编译器。语言设计者再次与用户需求略有脱节——他们非常出色地解决了略有偏差的问题。  

主动性能分析器或许是良策——将性能数据推送给程序员而非等待其查询。例如编辑器可用红色标注源码中的瓶颈。另一种方式是可视化运行程序的动态，这对服务端应用尤为有用——你可观察大量运行中程序。主动性能分析器能图形化展示内存状态，甚至通过声音提示程序状态。  

声音是问题的良好指示器。我曾工作的地方有块仪表盘显示Web服务器状态，指针由微型伺服电机驱动并发出轻微噪音。虽然看不到仪表盘，但我能通过声音立即判断服务器异常。  

甚至可能编写能自动检测低效算法的性能分析器。某些内存访问模式很可能是糟糕算法的征兆，这不会令我惊讶。如果有小人儿在计算机里执行我们的程序，他关于工作的抱怨恐怕不亚于联邦政府雇员。我常感觉自己在让处理器执行徒劳任务，却从未有好的方式观察其行为。  

许多Lisp现在编译为字节码再由解释器执行。这通常是为了便于移植，但它可能成为有用的语言特性。将字节码作为语言官方部分，并允许在瓶颈处使用内联字节码，这种优化也将具备可移植性。  

终端用户感知的速度本质正在变化。随着服务端应用兴起，越来越多程序受I/O限制。提升I/O速度将物有所值。语言可通过简单快速的格式化输出函数等直接措施，以及缓存和持久化对象等深层结构调整提供帮助。  

用户关注响应时间，但另一种效率正日益重要：单处理器支持的并发用户数。未来许多有趣应用将是服务端的，单服务器用户数成为托管方的关键指标——这是业务资本成本的分母。  

多年来，效率对多数终端用户应用并不重要。开发者可假设用户桌面处理器的性能持续提升。根据帕金森定律，软件膨胀以消耗可用资源。服务端应用将改变这一状况——此时硬件软件需成套提供。对提供服务的公司而言，单服务器用户数将显著影响盈亏。  

某些应用中处理器是限制因素，执行速度是最需优化的指标。但更多时候内存才是瓶颈——并发用户数取决于单用户数据所需内存量。语言在此也能助力：优秀的线程支持让所有用户共享单一堆；持久化对象和/或延迟加载的语言级支持也有

如果我不懂Lisp，读到这段话时一定会产生疑问。一门能让我成为更优秀程序员的语言——如果这说法真有意义——必然意味着它本身就是更优秀的编程语言。而这正是埃里克话中隐含的真意。

只要这种理念仍在流传，我相信黑客们对一门新Lisp语言仍会保持足够热情，哪怕它仍沿用Lisp之名。但这款Lisp必须延续1970年代经典Lisp的特质，成为真正的黑客语言：简洁、纯粹、可深度定制。更重要的是，它必须配备强大的函数库来满足当代黑客的核心需求。

在函数库方面，新Lisp完全有可能在Perl和Python的主场击败它们。未来数年需要开发的大量新应用都将属于[基于服务器的应用](road.html)。新Lisp没有理由不配备媲美Perl的字符串处理库——如果再拥有强大的服务器应用开发库，其流行将水到渠成。真正的黑客从不会对能通过几个库调用就解决复杂问题的新工具嗤之以鼻。记住，黑客骨子里是懒惰的。

若能在语言核心层面支持服务器应用开发，优势将更为显著。例如直接支持多用户程序，或在类型标记层面实现数据所有权管控。

服务器应用也解答了"新Lisp用于开发什么"的疑问。提升Lisp作为Unix脚本语言的能力固然有益（毕竟现状已难以更糟），但现有语言体系的薄弱环节才是更好的突破口。或许可以效仿Tcl的模式，将Lisp与完整的服务器应用支撑系统捆绑提供。Lisp天生适合服务器开发：词法闭包能在基于网页的交互中实现子程序效果；S表达式可完美映射到HTML；宏系统则擅长动态生成内容。当前既需要更好的服务器应用开发工具，也需要新Lisp语言，二者结合将相得益彰。

**12 理想语言**

总结而言，让我们尝试描绘黑客的梦想语言：它必须[优雅](taste.html)、简洁、凝练。具备快速启动的交互式顶层环境，能用极简代码解决常见问题。你所写的程序几乎完全由业务逻辑构成——其他一切均已预先实现。

其语法精简到极致，从不需要输入冗余字符，甚至鲜少用到Shift键。

借助高级抽象，你能快速完成程序原型。优化阶段则配备精准的性能分析器定位瓶颈。你可以让内循环极速运行，必要时甚至能直接内联字节码。

大量优质示例可供学习，语言的直觉性设计让你数分钟内就能通过例子掌握用法。几乎无需查阅手册——那本薄册子鲜少警告和限制说明。

语言核心精炼，函数库强大而高度正交，其设计精度与语言核心等同。所有库完美协同，如同精密相机部件般严丝合缝。没有废弃设计，也不为兼容性保留累赘。所有库源码触手可及，与操作系统及其他语言程序的交互轻而易举。

语言采用分层架构，高层抽象以完全透明的方式构建于底层抽象之上，必要时你可直取本源。

除非绝对必要，没有任何隐藏机制。语言提供的抽象仅用于减轻工作量，而非限制思维。事实上，它鼓励你平等参与设计——你可以改变包括语法在内的任何部分，你编写的代码与预定义组件具有同等地位。

**注释**

[1] 蒂莫西·哈特在1964年提出的宏概念已接近现代形态，比Lisp 1.5发布晚两年。初期缺乏的是避免变量捕获和多重求值的机制——哈特的例子都存在这两个问题。

[2] 在《当空气击中大脑》中，神经外科医生弗兰克·维托西克记载了住院总医师加里关于外科医生与内科医生（"跳蚤"）区别的谈话：

加里和我点了一个大披萨，找了个空卡座坐下。警长点燃一支烟："看看那些该死的跳蚤，喋喋不休地讨论他们一辈子都碰不上几次的罕见病。这就是跳蚤的问题所在，他们只喜欢猎奇。他们讨厌那些日常病例。这就是我们和那些该死的跳蚤的区别。听着，我们喜欢处理那些棘手的腰椎间盘突出病例，而他们却讨厌高血压......"

很难将腰椎间盘突出形容为"多汁"（除非从字面理解）。但我想我明白他们的意思。我经常遇到需要追踪的"多汁"程序错误。非程序员很难想象在错误中寻找乐趣。按理说一切正常运行才是最好的。从某种角度确实如此。但不可否认，追查某些类型的错误时确实有种残酷的满足感。

---
| | [后记版本](https://sep.turbifycdn.com/ty/cdn/paulgraham/bepop.ps?t=1688221954&)  
| | | | [Arc语言](http://www.paulgraham.com/arc.html)  
| | [关于语言设计的五个问题](langdes.html)  
| | | | [如何成为黑客](http://www.catb.org/~esr/faqs/hacker-howto.html)  
| | [日语译本](http://www.shiro.dreamhost.com/scheme/trans/being-popular-j.html)  

* * *