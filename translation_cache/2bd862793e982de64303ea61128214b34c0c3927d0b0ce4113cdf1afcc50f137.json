{
  "original": "This is the same argument you tend to hear for learning Latin. It won't get you a job, except perhaps as a classics professor, but it will improve your mind, and make you a better writer in languages ...",
  "translation": "这是你常听到的支持学习拉丁语的论调。它不会帮你找到工作——或许除了古典学教授之外，但它能提升你的思维，让你在用真正想用的语言（比如英语）写作时更出色。\n\n但等等。这个类比并不完全成立。拉丁语找不到工作的原因是没人使用它。如果你用拉丁语写作，没人能看懂。但Lisp是计算机语言，而计算机能理解任何程序员让它们理解的语言。\n\n那么，如果Lisp真如他所说能让你成为更好的程序员，为什么不用它呢？假如一位画家得到一支能让他画得更好的画笔，我想他会愿意在所有作品中使用它，不是吗？我并非在此取笑埃里克·雷蒙德。总体而言，他的建议是好的。他关于Lisp的观点也符合主流认知。但主流认知中存在一个矛盾：Lisp能让你成为更好的程序员，但你却不会使用它。\n\n为什么不？编程语言终究只是工具。如果Lisp真能产出更好的程序，你就该用它。如果不能，那谁需要它呢？\n\n这不只是理论问题。软件行业竞争激烈，天然趋向垄断。在其他条件相同的情况下，一家能更快、更好地编写软件的公司会让竞争对手倒闭。创业时，你会强烈感受到这一点。创业往往是非成即败的命题。要么大获成功，要么一无所有。在创业中，若押错技术，竞争对手就会碾压你。\n\n罗伯特和我都精通Lisp，我们找不到理由不相信直觉而选择Lisp。我们知道其他公司都在用C++或Perl写软件。但我们更明白这毫无意义。如果以此标准选择技术，你现在用的会是Windows。选择技术时，必须忽略他人做法，只考虑什么最有效。\n\n这对创业公司尤为关键。大公司可以效仿其他大公司，但创业公司不能照搬其他创业公司的做法。我认为即使身处创业公司，很多人也意识不到这点。\n\n普通大公司年增长率约10%。因此若以行业平均水平运营大公司，你也能获得平均增长。但若以创业公司的平均水平经营，等待你的将是倒闭——创业公司存活率远低于50%。所以创业时必须另辟蹊径，否则危矣。\n\n1995年，我们掌握了一个多数竞争对手至今仍未理解的道理：当软件只需运行在自己的服务器上时，你可以使用任何语言。开发桌面软件时，人们倾向于使用与操作系统相同的语言。十年前，这意味着用C语言。但基于Web的软件——尤其是当你拥有语言和操作系统的源代码时——语言选择完全自由。\n\n然而这种自由是双刃剑。既然能用任何语言，就必须思考如何选择。那些假装一切如常的公司，终将发现竞争对手并不如此。\n\n该选哪种语言？我们选择了Lisp。首先，这个市场显然需要快速开发。所有人从零开始，能比对手更快推出新功能的公司将占据巨大优势。我们知道Lisp能极速开发软件，而服务器端应用会放大这一优势——因为你能在代码写完的瞬间部署。\n\n其他公司不愿用Lisp？这再好不过。这可能带来技术优势，而我们亟需所有能获得的帮助。创立Viaweb时，我们毫无商业经验，不懂营销、招聘、融资或获客，甚至从未有过正经工作。我们唯一擅长的就是写软件。软件领域的任何优势，我们都将争取。\n\n可以说使用Lisp是一次实验。我们的假设是：用Lisp能比对手更快实现功能，并做出他们无法实现的东西；由于Lisp的高效抽象，我们不需要庞大团队，成本更低。若能如此，我们就能以更低价格提供更优产品，仍能盈利，最终占领全部市场。至少这是我们期待的结果。\n\n实验结果如何？出乎意料地成功。我们最终有二三十个竞争对手，但他们的软件都无法与我们抗衡。我们拥有服务端运行的所见即所得在线商店构建器，体验却如桌面应用；对手们还在用CGI脚本。功能上我们始终遥遥领先。有时对手会绝望地试图推出我们不具备的功能。但借助Lisp的快速开发周期，我们常在对手发新闻稿后一两天内复刻该功能。等报道该新闻的记者联系我们时，新功能已上线。\n\n对手们一定以为我们拥有某种秘密武器——就像破译了他们的恩尼格玛密码。事实上我们确实有秘密武器，只是比他们想象的简单：没人向我们泄露他们的开发计划，我们只是能以超乎想象的速度开发软件。\n\n九岁时我偶然读到弗雷德里克·福赛斯的《豺狼的日子》。主角是被雇来刺杀法国总统的杀手。为了进入能俯瞰总统路线的公寓，他必须通过警察的封锁。最终他拄着拐杖扮成老人，堂而皇之地从警察面前走过。\n\n我们的秘密武器与此相似。用这门古怪的、满是括号的AI语言编程，多年来我听厌了人们对Lisp的这种描述。但现在它成了我们的优势。商战中，没有什么比竞争对手无法理解的技术优势更有价值。在商业与战争中，出其不意与实力同等重要。\n\n因此我有点难为情地承认，Viaweb运营期间我从未公开谈论Lisp。我们对媒体只字不提，如果你在我们网站上搜索Lisp，只能在我简历中找到两本书名。这绝非偶然。创业公司应尽可能少地向对手透露信息。既然他们不知道或不关心我们使用的语言，我就要保持这种状态。\n\n最懂我们技术的是客户。他们同样不关心Viaweb用什么语言编写，但他们注意到它效果卓越：能 literally 在几分钟内建好精美的在线商店。通过口碑传播，用户持续增长。1996年底我们拥有约70家在线商店，1997年底达500家。被雅虎收购前的半年，用户数增至1070家。如今作为\"雅虎商店\"，它仍统治着市场，是雅虎最盈利的产品之一，其构建的商店构成了雅虎购物基础。1999年我离开雅虎，不知当前用户数，但最后听说约2万家。\n\n**Blub悖论**\n\nLisp强在哪？如果它如此强大，为何不是人人使用？这看似反问，实则确有答案。Lisp的强大并非因为只有信徒才能看见的魔力，而是因为它就是目前最强大的语言。而人们不用它的原因在于：编程语言不仅是技术，更是思维习惯——而后者变化最慢。当然，这两个答案都需要解释。\n\n我先抛出一个极具争议的观点：编程语言有强弱之分。\n\n至少很少人会反对高级语言比机器语言强大。如今多数程序员认同：通常不该用机器语言编程，而应使用高级语言，再通过编译器转为机器语言。这个理念现已融入硬件：自1980年代起，指令集就为编译器而非人类程序员设计。\n\n众所周知，完全用机器语言手写程序是种错误。但更少人理解的是其中蕴含的普适原则：当有多种语言可选时，在其他条件相同的情况下，不使用最强大的语言就是错误。\n\n当然存在例外。若需与某语言编写的程序紧密交互，用同种语言可能更合适；若程序只需处理简单任务（如数值计算或位操作），使用抽象程度较低的语言或许更优（尤其可能稍快）；若是短期使用的临时程序，选择库函数最丰富的语言更明智。但总体而言，对于应用软件，使用你能获得的最强大（且效率合理）的语言才是正道——使用其他语言与使用机器语言的错误性质相同，只是程度较轻。\n\n显然机器语言层次极低。但社会惯例中，高级语言常被视为等价。实则不然。严格来说\"高级语言\"并无明确定义。机器语言与高级语言之间不存在明确分界线。语言处于抽象程度的连续谱上，从最强大的一直到机器语言——后者本身也有强弱之分。\n\n以COBOL为例。作为需编译为机器语言的语言，它算高级语言。但谁会认真主张COBOL与Python能力相当？它可能比Python更接近机器语言。\n\nPerl 4又如何？Perl 5增加了词法闭包，多数Perl黑客会认同Perl 5更强大。但承认这点就等于承认高级语言之间存在强弱差异。由此必然推出：除非特殊情况，你应该使用能获得的最强大语言。\n\n然而这个结论很少被贯彻。程序员到一定年龄后，很少主动切换语言。无论习惯何种语言，他们都会认为它\"足够好\"。\n\n程序员对偏爱语言的忠诚度很高。为避免伤害感情，我将用虚构的Blub语言来说明。Blub位于抽象谱系中段——不是最强大的，但比COBOL或机器语言强大。\n\n事实上，这位虚构的Blub程序员不会使用后两者。他当然不用机器语言（那是编译器的职责），至于COBOL？他无法理解如何用它完成工作——它甚至没有x（任选一个Blub特性）。\n\n当Blub程序员向下看能力谱系时，他知道自己在俯视。那些语言明显更弱，因为它们缺少他惯用的特性。但当他向上看时，却未意识到这是仰视。他只看到些怪异语言，可能认为它们与Blub能力相当，只是多了些花哨功能。Blub对他已足够好，因为他用Blub思考。\n\n然而，当我们切换到能力谱系更高处程序员的视角，会发现他们同样俯视着Blub：没有y特性，怎么可能用它完成工作？\n\n通过归纳可知，唯有理解最强大语言的程序员，才能真正看清各语言间的能力差异。（这或许就是埃里克·雷蒙德所说\"Lisp让你成为更好程序员\"的含义。）其他人的意见不足采信，因为Blub悖论：他们满足于当前使用的语言，因其塑造了他们思考程序的方式。\n\n我有切身体会。高中时我用BASIC写程序，这门语言甚至不支持递归。现在难以想象不用递归如何编程，但当时我毫无察觉——我用BASIC思考，且自认是行家，对一切了然于胸。\n\n埃里克·雷蒙德推荐给黑客的五种语言位于能力谱系的不同位置。它们之间的相对高低是个敏感话题。我的观点是：Lisp居于顶端。为佐证这点，我要指出当我审视其他四种语言时发现的缺失：没有宏，如何高效工作？\n\n许多语言都有称为\"宏\"的东西，但Lisp宏是独一无二的。信不信由你，它们的功能与那些括号有关。Lisp的设计者并非为了标新立异才加入括号。对Blub程序员而言，Lisp代码看起来古怪，但这些括号存在深层原因——它们是Lisp与其他语言根本差异的外在体现。\n\nLisp代码由Lisp数据对象构成。这不是\"源文件包含字符，字符串是语言支持的数据类型\"这种浅层意义。经过解析器处理后，Lisp代码由可遍历的数据结构组成。\n\n若理解编译器工作原理，你会发现与其说Lisp语法怪异，不如说它没有语法。你直接在解析树中编写程序——这些树在其他语言中只存在于编译器内部。但在Lisp中，这些解析树完全向程序开放，你可以编写操作它们的程序。这些程序就是宏：能生成程序的程序。\n\n用程序写程序？什么时候需要这样做？用COBOL思考的人会觉得极少需要，用Lisp思考的人则时刻需要。如果能在此展示一个强大宏的示例并说\"看吧！这还不说明问题吗？\"会很有说服力。但对不懂Lisp的人这只会像天书——限于篇幅，我无法解释理解它所需的全部背景知识。在《ANSI Common Lisp》中，我已尽可能加快节奏，即便如此也要到第160页才介绍宏。\n\n但我想提出一个可能有说服力的论点：Viaweb编辑器源代码中约20-25%是宏。宏比普通Lisp函数更难编写，非必要情况下使用它们被视为不良风格。因此每个宏的存在都不可或缺。这意味着该程序中至少20-25%的代码实现了其他语言难以完成的功能。无论Blub程序员对Lisp神秘力量的宣称多么怀疑，这都应引起他的好奇。我们编写这些代码不是为了自娱——作为一家小创业公司，我们拼命编程就是为了筑起技术壁垒。\n\n多疑者可能开始怀疑其中的关联：我们大量代码在做其他语言极难实现的事，最终产品具备竞争对手没有的功能。或许存在某种联系。我建议你顺着这个思路想下去——那个拄拐蹒跚的老人，可能比表面看到的更有深意。\n\n**创业公司的合气道**\n\n但我不指望说服任何人（尤其是25岁以上的人）去学Lisp。本文目的不是改变他人观点，而是坚定那些本就对Lisp感兴趣者的信心——他们知道Lisp强大，却因小众而忧虑。在竞争中，这恰恰是优势。Lisp的力量会因竞争对手的不理解而成倍放大。\n\n如果在创业中使用Lisp，不必担心它不被广泛理解，反而应希望这种状况持续。这很可能实现——编程语言的本质就是让多数人安于现状。计算机硬件发展远快于个人习惯，编程实践通常落后处理器10到20年。1960年代初MIT等机构已用高级语言编程，但直到1980年代许多公司仍用机器语言写代码。我打赌直到RISC指令集像急着打烊的酒保般把他们赶出门，很多人才停止使用机器语言。\n\n通常技术迭代迅速，但编程语言不同：它们不仅是技术，更是程序员的思维载体，半是技术半是信仰。因此中位数语言（即大多数程序员使用的语言）如冰山般缓慢移动。约1960年由Lisp引入的垃圾回收机制，现已被广泛认可；运行时类型检查也逐渐流行；1970年代初由Lisp引入的词法闭包刚刚进入大众视野；而1960年代中期Lisp就有的宏，至今仍是未知领域。\n\n显然，中位数语言具有巨大惯性。我并非建议对抗这股力量，正相反——像合气道修习者那样，你可以借力打力。\n\n在大公司工作可能难以实现这点。当\"尖头老板\"刚读到某语言将如20年前的Ada般统治世界时，你很难说服他允许用Lisp开发。但如果在尚无此类老板的创业公司工作，你就能像我们一样，将Blub悖论转化为优势：使用那些被中位数语言束缚的竞争对手永远无法企及的技术。\n\n若你身处创业公司，评估竞争对手时有条实用技巧：阅读他们的招聘信息。网站其他内容可能是样板素材，但招聘要求必须具体明确。在Viaweb运营期间，我读过大量职位描述——几乎每月都有新对手出现。查看在线演示后，我首先会看他们的招聘需求。几年后我就能判断哪些公司值得警惕：职位描述的IT气息越浓，威胁越小。最安全的是要求Oracle经验的，其次是C++或Java开发者。若需要Perl或Python程序员就需警惕——这至少说明技术部门由真黑客掌管。如果我曾看到招聘Lisp黑客的启事，定会高度紧张。\n\n[1] Viaweb最初有两部分：用Lisp编写的网站编辑器，以及用C处理的订单系统。第一版主要是Lisp，因为订单系统很小。后来我们增加了两个模块：用C编写的图像生成器，以及主要用Perl编写的后台管理系统。2003年1月，雅虎发布了用C++和Perl重写的编辑器新版。但严格说它是否仍算用Lisp编写存疑——因为为了转换成C++，他们实际上编写了一个Lisp解释器：据我所知，所有页面模板的源文件仍是Lisp代码。（参见《格林斯潘第十定律》）\n\n[2] 罗伯特·莫里斯认为我无需保密，因为即使竞争对手知道我们用Lisp，也无法理解原因：\"如果他们够聪明，早就在用Lisp了。\"\n\n[3] 所有语言在图灵等价意义上能力相同，但这并非程序员关注的层面。（没人想为图灵机编程。）程序员关心的\"能力\"或许无法精确定义，但一种解释方式是：在弱语言中，只有通过为其编写强语言的解释器才能获得的特性。如果语言A有去除字符串空格的运算符而语言B没有，这未必使A更强大，因为你可以在B中编写子程序实现。但如果A支持递归而B不支持，这就不是通过库函数能解决的问题。\n\n[4] 给极客的注释：也可能是向顶端收窄的格序，此处重要的不是形状而是至少存在偏序的概念。\n\n[5] 将宏视为独立特性有些误导。实践中它们的实用性极大依赖于词法闭包、剩余参数等其他Lisp特性。\n\n[6] 因此编程语言比较要么演变成圣战，要么成为坚决中立的人类学著作。重视安宁或渴望终身教职者会避开这个话题。但这个问题只有一半属于信仰范畴——其中确有值得研究之处，尤其当你想要设计新语言时。",
  "timestamp": "2025-07-14T12:11:34.474594",
  "model": "deepseek-ai/DeepSeek-V3"
}