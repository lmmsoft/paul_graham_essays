{
  "original": "| | [](index.html)  \n  \n|   \n  \n1993   \n  \n_(This essay is from the introduction to_[On Lisp](onlisp.html) _.)_   \n  \nIt's a long-standing principle of programming style that the functional elements o...",
  "translation": "| | [](index.html)  \n\n|  \n\n1993年  \n\n（本文节选自《On Lisp》序言）  \n\n程序的功能单元不应过于庞大，这一编程风格原则由来已久。当某个组件膨胀到难以理解的程度时，它就会变成一团隐匿错误的混沌体，如同大都市藏匿逃犯般容易。这样的软件将难以阅读、测试和调试。  \n\n根据这一原则，大型程序必须被拆解，且规模越大，划分越需细致。如何划分程序？传统方法称为_自顶向下设计_：即先确定\"程序需完成这七项功能，故划分为七个主要子程序。第一个子程序需实现四项功能，因此它自身又包含四个子程序\"，如此层层递进，直至整个程序达到合适的粒度——每个部分既能实现实质功能，又可作为独立单元被理解。  \n\n资深的Lisp程序员采用不同的划分方式。除自顶向下设计外，他们遵循可称为_自底向上设计_的原则——通过改造语言来适应问题。在Lisp中，你不仅自上而下地用语言编写程序，更自下而上地为程序构建语言。编程时你可能会想\"要是Lisp有某某操作符就好了\"，于是你动手实现它。随后你会发现这个新操作符能简化程序其他部分的设计，如此往复。语言与程序共同进化。如同交战国的边境线，语言与程序的边界被不断重新划定，最终沿着问题的自然疆界——那些山脉与河流——稳定下来。最终你的程序会看起来像是为其量身定制的语言。当语言与程序完美契合时，产出的代码将清晰、简洁且高效。  \n\n值得强调的是，自底向上设计并非仅以不同顺序编写相同程序。采用这种方法时，你最终得到的往往是另一个程序。不同于单一的整体式程序，你会获得一个包含更多抽象操作符的增强语言，以及用该语言编写的更精简程序。这好比用拱门替代了过梁。  \n\n典型代码中，当你抽离出那些纯属簿记的部分后，剩余内容会大幅缩减；语言构建得越高层，从顶层向下追溯的距离就越短。这带来诸多优势：",
  "timestamp": "2025-07-14T13:33:47.804390",
  "model": "deepseek-ai/DeepSeek-V3"
}