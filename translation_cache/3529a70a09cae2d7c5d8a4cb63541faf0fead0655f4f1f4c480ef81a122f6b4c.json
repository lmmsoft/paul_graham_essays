{
  "original": "  \n  \n  \n  \n**Appendix: Power**  \n  \nAs an illustration of what I mean about the relative power of programming languages, consider the following problem. We want to write a function that generates acc...",
  "translation": "**附录：语言的威力**  \n\n为了说明不同编程语言的相对威力，请思考以下问题：我们需要编写一个生成累加器的函数——该函数接收一个数字`n`，返回一个能接收另一个数字`i`并返回`n`累加`i`结果的函数。  \n\n（注意是*累加*而非简单相加。累加器必须保持状态。）  \n\n在Common Lisp中实现如下：  \n```lisp\n(defun foo (n) (lambda (i) (incf n i)))\n```  \n而在Perl 5中：  \n```perl\nsub foo { my ($n) = @_; sub {$n += shift} }\n```  \nPerl版本比Lisp多了参数手动提取的步骤。  \n\nSmalltalk代码略长于Lisp：  \n```smalltalk\nfoo: n \n    |s| \n    s := n. \n    ^[:i| s := s+i. ]\n```  \n因为虽然支持词法变量，但不能直接对参数赋值，必须创建新变量`s`。  \n\nJavascript同样稍显冗长，因其区分语句和表达式，需显式`return`返回值：  \n```javascript\nfunction foo(n) { return function (i) { return n += i } }\n```  \n（公平而言，Perl也区分二者，但以典型Perl风格允许省略`return`。）  \n\n若将上述代码转换为Python，则会遇到限制。由于Python不完全支持词法变量，必须创建数据结构存储`n`；且虽支持函数类型，但无字面量表示（除非函数体为单一表达式），故需命名函数返回。最终代码如下：  \n```python\ndef foo(n):\n    s = [n]\n    def bar(i):\n        s[0] += i\n        return s[0]\n    return bar\n```  \nPython用户或会质疑为何不能直接写作：  \n```python\ndef foo(n): return lambda i: return n += i\n```  \n甚至：  \n```python\ndef foo(n): lambda i: n += i\n```  \n我推测未来或许能实现。（但若不愿等待Python进化至Lisp的水平，他们完全可以...）  \n\n在面向对象语言中，可通过定义含单方法的类来有限模拟闭包（引用外围作用域变量的函数），用字段替代外围变量。这迫使程序员手动完成本应由词法作用域编译器完成的代码分析，且无法处理多函数共享同一变量的情况，但简单场景尚可应付。  \n\nPython专家普遍认为这是更\"符合语言风格\"的解决方案：  \n```python\ndef foo(n):\n    class acc:\n        def __init__(self, s):\n            self.s = s\n        def inc(self, i):\n            self.s += i\n            return self.s\n    return acc(n).inc\n```  \n或：  \n```python\nclass foo:\n    def __init__(self, n):\n        self.n = n\n    def __call__(self, i):\n        self.n += i\n        return self.n\n```  \n我列出这些是为避免Python拥护者指责曲解语言，但二者都比首个版本复杂。本质都是创建独立存储空间——只是用对象字段替代了列表头部。而`__call__`等特殊字段名的使用更像某种妥协。  \n\n在Perl与Python的竞争中，Python阵营常标榜其语言比Perl更优雅。但本例表明：威力才是终极优雅——尽管语法稍显粗糙，Perl程序更简洁（元素更少）。  \n\n其他语言表现如何？本次讨论涉及的Fortran、C、C++、Java和Visual Basic甚至难以解决该问题。Ken Anderson指出这是Java最接近的实现：  \n```java\npublic interface Inttoint { public int call(int i); }\npublic static Inttoint foo(final int n) {\n    return new Inttoint() {\n        int s = n;\n        public int call(int i) {\n            s = s + i;\n            return s;\n        }\n    };\n}\n```  \n该方案仅支持整数，未达标准。经与Java开发者多次邮件讨论后，我认为要编写行为等同前例的多态版本，其难度介于极其棘手与不可能之间。若有实现者，我愿一观，但本人已放弃尝试。  \n\n严格来说，并非无法用其他语言实现。图灵等价性意味着理论上任何语言都能编写任何程序。那么如何实现？极端情况下，可在弱语言中实现Lisp解释器。  \n\n这听似玩笑，但大型项目中不同程度地频繁出现这种现象，甚至被命名为\"格林斯潘第十定律\"：",
  "timestamp": "2025-07-14T02:33:12.964470",
  "model": "deepseek-ai/DeepSeek-V3"
}